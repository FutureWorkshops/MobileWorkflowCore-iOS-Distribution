// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
// swift-module-flags: -target x86_64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name MobileWorkflowCore
import AVFoundation
import AVKit
import Combine
import CoreLocation
import CryptoKit
import Foundation
import MediaPlayer
import MessageUI
@_exported import MobileWorkflowCore
import PDFKit
import Security
import Swift
import UIKit
import VisionKit
final public class NetworkServiceImplementation : MobileWorkflowCore.NetworkService {
  public init(urlSession: Foundation.URLSession = .shared, userSessionManagement: MobileWorkflowCore.CredentialsStoreProtocol = CredentialsStore(), authRedirectHandler: MobileWorkflowCore.AuthRedirectHandler?)
  final public func request<T>(url: Swift.String, httpMethod: MobileWorkflowCore.HTTPMethod = .get, using session: MobileWorkflowCore.Session, requiresAuthentication: Swift.Bool = false, parsePublisher: @escaping (Combine.AnyPublisher<Foundation.Data, Swift.Error>) -> Combine.AnyPublisher<T, Swift.Error>, completionQueue: Dispatch.DispatchQueue = .main, completion: @escaping (Swift.Result<T, Swift.Error>) -> Swift.Void) -> Combine.AnyCancellable?
  final public func postSession(to url: Swift.String, using session: MobileWorkflowCore.Session, completionQueue: Dispatch.DispatchQueue = .main, completion: @escaping (Swift.Result<Foundation.Data, Swift.Error>) -> Swift.Void) -> Combine.AnyCancellable?
  final public func upload(urls: [MobileWorkflowCore.NetworkStepBinaryResponse], using session: MobileWorkflowCore.Session, completionQueue: Dispatch.DispatchQueue, completion: @escaping (MobileWorkflowCore.FileUploadUpdate) -> Swift.Void) -> Combine.AnyCancellable?
  final public func authenticateWithProvider(_ authProvider: MobileWorkflowCore.AuthProvider, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  @objc deinit
}
public enum ParseError : Foundation.LocalizedError, Swift.CustomStringConvertible {
  case invalidStepData(cause: Swift.String)
  case invalidWorkflowData(cause: Swift.String)
  case invalidServerData(cause: Swift.String)
  case invalidAppName(cause: Swift.String)
  case invalidAppData(cause: Swift.String)
  case invalidNavigationStyle(cause: Swift.String)
  case invalidNavigationRule(cause: Swift.String)
  public var domain: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var description: Swift.String {
    get
  }
}
extension FileManager {
  @objc(mw_sharedManager) public static var shared: Foundation.FileManager
}
public protocol StringConvertableValue {
  var stringValue: Swift.String { get }
}
extension String : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension NSString : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension Date : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension NSDate : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension Bool : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension NSNumber : MobileWorkflowCore.StringConvertableValue {
}
extension CLLocation : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension CLLocationCoordinate2D : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension Int : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension Float : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension Double : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension ORKLocation : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension Array : MobileWorkflowCore.StringConvertableValue where Element == MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
public protocol URLSchemeManager {
  func parse(url: Foundation.URL) -> MobileWorkflowCore.AppConfigurationContext?
}
public struct MobileWorkflowSchemeManager : MobileWorkflowCore.URLSchemeManager {
  public init(version: Swift.String = "v1", debugHost: Swift.String = "localhost", defaultPort: Swift.Int = 5000)
  public func parse(url: Foundation.URL) -> MobileWorkflowCore.AppConfigurationContext?
}
extension UIViewController {
  public func show(_ error: Swift.Error, actionHandler: (() -> Swift.Void)? = nil)
  public func showConfirmationAlert(title: Swift.String, message: Swift.String?, cancelTitle: Swift.String? = nil, confirmTitle: Swift.String? = nil, isDestructive: Swift.Bool = false, actionHandler: @escaping (Swift.Bool) -> Swift.Void)
}
extension UIViewController {
  public func addCovering(childViewController: UIKit.UIViewController)
}
public protocol RemoteContentStep {
  associatedtype ResponseType
  var services: MobileWorkflowCore.MobileWorkflowServices { get }
  var contentURL: Swift.String? { get }
  var authenticationWorkflowId: Swift.Int? { get }
}
extension RemoteContentStep where Self.ResponseType : Swift.Decodable {
  public func loadContent(completion: @escaping (Swift.Result<Self.ResponseType, Swift.Error>) -> Swift.Void)
}
public protocol JSONRepresentable {
  var jsonContent: Swift.String? { get }
}
extension Date : MobileWorkflowCore.JSONRepresentable {
  public var jsonContent: Swift.String? {
    get
  }
}
extension NSDate : MobileWorkflowCore.JSONRepresentable {
  public var jsonContent: Swift.String? {
    get
  }
}
extension CLLocation : MobileWorkflowCore.JSONRepresentable {
  public var jsonContent: Swift.String? {
    get
  }
}
extension CLLocationCoordinate2D : MobileWorkflowCore.JSONRepresentable {
  public var jsonContent: Swift.String? {
    get
  }
}
extension ORKLocation : MobileWorkflowCore.JSONRepresentable {
  public var jsonContent: Swift.String? {
    get
  }
}
public struct MobileWorkflowServices {
  public let session: MobileWorkflowCore.Session
  public let networkService: MobileWorkflowCore.NetworkService
  public let imageLoadingService: MobileWorkflowCore.ImageLoadingService
  public let localizationService: MobileWorkflowCore.LocalizationService
}
public protocol BuildableStep : MobileWorkflowCore.ORKStep {
  static func build(step: MobileWorkflowCore.StepInfo, services: MobileWorkflowCore.MobileWorkflowServices) throws -> MobileWorkflowCore.ORKStep
}
@objc @_inheritsConvenienceInitializers open class MobileWorkflowButtonViewController : MobileWorkflowCore.ORKStepViewController {
  public func configureWithTitle(_ title: Swift.String, body: Swift.String, buttonTitle: Swift.String, buttonAction: @escaping (() -> Swift.Void))
  @objc override dynamic public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  public func showLoading()
  public func hideLoading()
  @objc deinit
  @objc override dynamic public init(step: MobileWorkflowCore.ORKStep?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public enum FileUploadUpdate {
  case failed(error: Swift.Error)
  case uploaded(identifier: Swift.String)
  case completed
}
public protocol BinaryProvider : MobileWorkflowCore.SessionProvider {
  var binaryIdentifier: Swift.String { get }
  var cachePath: Swift.String? { get }
  var fileName: Swift.String? { get }
  var fileType: Swift.String? { get }
  func load(using fileManager: Foundation.FileManager) -> Foundation.Data?
}
public enum WorkflowPresentationError : Foundation.LocalizedError {
  case workflowNotFound(name: Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public var localizedDescription: Swift.String {
    get
  }
}
public typealias OnWorkflowDismiss = (MobileWorkflowCore.ORKTaskViewControllerFinishReason) -> Swift.Void
public protocol WorkflowPresentationDelegate : AnyObject {
  func presentWorkflowWithName(_ name: Swift.String, animated: Swift.Bool, onDismiss: MobileWorkflowCore.OnWorkflowDismiss?)
  func presentWorkflowWithId(_ id: Swift.Int, animated: Swift.Bool, onDismiss: MobileWorkflowCore.OnWorkflowDismiss?)
}
public protocol WorkflowPresentationDelegator : AnyObject {
  var workflowPresentationDelegate: MobileWorkflowCore.WorkflowPresentationDelegate? { get set }
}
public protocol PresentedWorkflow : AnyObject {
  var onDismiss: MobileWorkflowCore.OnWorkflowDismiss? { get }
}
public enum CredentialType : Swift.String, Swift.CaseIterable {
  case token
  case refreshToken
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [MobileWorkflowCore.CredentialType]
  public static var allCases: [MobileWorkflowCore.CredentialType] {
    get
  }
}
public struct URLFormatter {
  public static let DefaultURLComposerRegex: Swift.String
  public init(regex: Swift.String = DefaultURLComposerRegex)
  public func parse(baseURL: Foundation.URL, complement: Swift.String, using session: MobileWorkflowCore.Session?) -> Foundation.URL?
}
public struct Credential : Swift.Codable {
  public init(type: Swift.String, value: Swift.String, expirationDate: Foundation.Date)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol SecurityStoreProtocol {
  func storePassword(key: Swift.String, value: Foundation.Data) -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
  func password(for key: Swift.String) -> Swift.Result<Foundation.Data?, MobileWorkflowCore.CredentialError>
  func removePassword(key: Swift.String) -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
}
final public class SecurityStore : MobileWorkflowCore.SecurityStoreProtocol {
  public init()
  final public func storePassword(key: Swift.String, value: Foundation.Data) -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
  final public func password(for key: Swift.String) -> Swift.Result<Foundation.Data?, MobileWorkflowCore.CredentialError>
  final public func removePassword(key: Swift.String) -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
  @objc deinit
}
public protocol LocaleConvertible {
  var locale: Foundation.Locale { get }
}
extension Locale : MobileWorkflowCore.LocaleConvertible {
  public var locale: Foundation.Locale {
    get
  }
}
public enum CurrencyLocale : Swift.String, MobileWorkflowCore.LocaleConvertible {
  case current
  case autoUpdating
  case afrikaans
  case afrikaansNamibia
  case afrikaansSouthAfrica
  case aghem
  case aghemCameroon
  case akan
  case akanGhana
  case albanian
  case albanianAlbania
  case albanianKosovo
  case albanianMacedonia
  case amharic
  case amharicEthiopia
  case arabic
  case arabicAlgeria
  case arabicBahrain
  case arabicChad
  case arabicComoros
  case arabicDjibouti
  case arabicEgypt
  case arabicEritrea
  case arabicIraq
  case arabicIsrael
  case arabicJordan
  case arabicKuwait
  case arabicLebanon
  case arabicLibya
  case arabicMauritania
  case arabicMorocco
  case arabicOman
  case arabicPalestinianTerritories
  case arabicQatar
  case arabicSaudiArabia
  case arabicSomalia
  case arabicSouthSudan
  case arabicSudan
  case arabicSyria
  case arabicTunisia
  case arabicUnitedArabEmirates
  case arabicWesternSahara
  case arabicWorld
  case arabicYemen
  case armenian
  case armenianArmenia
  case assamese
  case assameseIndia
  case asu
  case asuTanzania
  case azerbaijani
  case azerbaijaniAzerbaijan
  case azerbaijaniCyrillic
  case azerbaijaniCyrillicAzerbaijan
  case bafia
  case bafiaCameroon
  case bambara
  case bambaraMali
  case basaa
  case basaaCameroon
  case basque
  case basqueSpain
  case belarusian
  case belarusianBelarus
  case bemba
  case bembaZambia
  case bena
  case benaTanzania
  case bengali
  case bengaliBangladesh
  case engaliIndia
  case bodo
  case bodoIndia
  case bosnian
  case bosnianBosniaHerzegovina
  case bosnianCyrillic
  case bosnianCyrillicBosniaHerzegovina
  case breton
  case bretonFrance
  case bulgarian
  case bulgarianBulgaria
  case burmese
  case burmeseMyanmarBurma
  case catalan
  case catalanAndorra
  case catalanFrance
  case catalanItaly
  case catalanSpain
  case centralAtlasTamazight
  case centralAtlasTamazightMorocco
  case centralKurdish
  case centralKurdishIran
  case centralKurdishIraq
  case cherokee
  case cherokeeUnitedStates
  case chiga
  case chigaUganda
  case chinese
  case chineseChina
  case chineseHongKongSarChina
  case chineseMacauSarChina
  case chineseSimplified
  case chineseSimplifiedHongKongSarChina
  case chineseSimplifiedMacauSarChina
  case chineseSingapore
  case chineseTaiwan
  case chineseTraditional
  case colognian
  case colognianGermany
  case cornish
  case cornishUnitedKingdom
  case croatian
  case croatianBosniaHerzegovina
  case croatianCroatia
  case czech
  case czechCzechRepublic
  case danish
  case danishDenmark
  case danishGreenland
  case duala
  case dualaCameroon
  case dutch
  case dutchAruba
  case dutchBelgium
  case dutchCaribbeanNetherlands
  case dutchCuraao
  case dutchNetherlands
  case dutchSintMaarten
  case dutchSuriname
  case dzongkha
  case dzongkhaBhutan
  case embu
  case embuKenya
  case english
  case englishAlbania
  case englishAmericanSamoa
  case englishAndorra
  case englishAnguilla
  case englishAntiguaBarbuda
  case englishAustralia
  case englishAustria
  case englishBahamas
  case englishBarbados
  case englishBelgium
  case englishBelize
  case englishBermuda
  case englishBosniaHerzegovina
  case englishBotswana
  case englishBritishIndianOceanTerritory
  case englishBritishVirginIslands
  case englishCameroon
  case englishCanada
  case englishCaymanIslands
  case englishChristmasIsland
  case englishCocosKeelingIslands
  case englishCookIslands
  case englishCroatia
  case englishCyprus
  case englishCzechRepublic
  case englishDenmark
  case englishDiegoGarcia
  case englishDominica
  case englishEritrea
  case englishEstonia
  case englishEurope
  case englishFalklandIslands
  case englishFiji
  case englishFinland
  case englishFrance
  case englishGambia
  case englishGermany
  case englishGhana
  case englishGibraltar
  case englishGreece
  case englishGrenada
  case englishGuam
  case englishGuernsey
  case englishGuyana
  case englishHongKongSarChina
  case englishHungary
  case englishIceland
  case englishIndia
  case englishIreland
  case englishIsleOfMan
  case englishIsrael
  case englishItaly
  case englishJamaica
  case englishJersey
  case englishKenya
  case englishKiribati
  case englishLatvia
  case englishLesotho
  case englishLiberia
  case englishLithuania
  case englishLuxembourg
  case englishMacauSarChina
  case englishMadagascar
  case englishMalawi
  case englishMalaysia
  case englishMalta
  case englishMarshallIslands
  case englishMauritius
  case englishMicronesia
  case englishMontenegro
  case englishMontserrat
  case englishNamibia
  case englishNauru
  case englishNetherlands
  case englishNewZealand
  case englishNigeria
  case englishNiue
  case englishNorfolkIsland
  case englishNorthernMarianaIslands
  case englishNorway
  case englishPakistan
  case englishPalau
  case englishPapuaNewGuinea
  case englishPhilippines
  case englishPitcairnIslands
  case englishPoland
  case englishPortugal
  case englishPuertoRico
  case englishRomania
  case englishRussia
  case englishRwanda
  case englishSamoa
  case englishSeychelles
  case englishSierraLeone
  case englishSingapore
  case englishSintMaarten
  case englishSlovakia
  case englishSlovenia
  case englishSolomonIslands
  case englishSouthAfrica
  case englishSouthSudan
  case englishSpain
  case englishStHelena
  case englishStKittsNevis
  case englishStLucia
  case englishStVincentGrenadines
  case englishSudan
  case englishSwaziland
  case englishSweden
  case englishSwitzerland
  case englishTanzania
  case englishTokelau
  case englishTonga
  case englishTrinidadTobago
  case englishTurkey
  case englishTurksCaicosIslands
  case englishTuvalu
  case englishUSOutlyingIslands
  case englishUSVirginIslands
  case englishUganda
  case englishUnitedKingdom
  case englishUnitedStates
  case englishUnitedStatesComputer
  case englishVanuatu
  case englishWorld
  case englishZambia
  case englishZimbabwe
  case esperanto
  case estonian
  case estonianEstonia
  case ewe
  case eweGhana
  case eweTogo
  case ewondo
  case ewondoCameroon
  case faroese
  case faroeseFaroeIslands
  case filipino
  case filipinoPhilippines
  case finnish
  case finnishFinland
  case french
  case frenchAlgeria
  case frenchBelgium
  case frenchBenin
  case frenchBurkinaFaso
  case frenchBurundi
  case frenchCameroon
  case frenchCanada
  case frenchCentralAfricanRepublic
  case frenchChad
  case frenchComoros
  case frenchCongoBrazzaville
  case frenchCongoKinshasa
  case frenchCteDivoire
  case frenchDjibouti
  case frenchEquatorialGuinea
  case frenchFrance
  case frenchFrenchGuiana
  case frenchFrenchPolynesia
  case frenchGabon
  case frenchGuadeloupe
  case frenchGuinea
  case frenchHaiti
  case frenchLuxembourg
  case frenchMadagascar
  case frenchMali
  case frenchMartinique
  case frenchMauritania
  case frenchMauritius
  case frenchMayotte
  case frenchMonaco
  case frenchMorocco
  case frenchNewCaledonia
  case frenchNiger
  case frenchRunion
  case frenchRwanda
  case frenchSenegal
  case frenchSeychelles
  case frenchStBarthlemy
  case frenchStMartin
  case frenchStPierreMiquelon
  case frenchSwitzerland
  case frenchSyria
  case frenchTogo
  case frenchTunisia
  case frenchVanuatu
  case frenchWallisFutuna
  case friulian
  case friulianItaly
  case fulah
  case fulahCameroon
  case fulahGuinea
  case fulahMauritania
  case fulahSenegal
  case galician
  case galicianSpain
  case ganda
  case gandaUganda
  case georgian
  case georgianGeorgia
  case german
  case germanAustria
  case germanBelgium
  case germanGermany
  case germanLiechtenstein
  case germanLuxembourg
  case germanSwitzerland
  case greek
  case greekCyprus
  case greekGreece
  case gujarati
  case gujaratiIndia
  case gusii
  case gusiiKenya
  case hausa
  case hausaGhana
  case hausaNiger
  case hausaNigeria
  case hawaiian
  case hawaiianUnitedStates
  case hebrew
  case hebrewIsrael
  case hindi
  case hindiIndia
  case hungarian
  case hungarianHungary
  case icelandic
  case icelandicIceland
  case igbo
  case igboNigeria
  case inariSami
  case inariSamiFinland
  case indonesian
  case indonesianIndonesia
  case inuktitut
  case inuktitutUnifiedCanadianAboriginalSyllabics
  case inuktitutUnifiedCanadianAboriginalSyllabicsCanada
  case irish
  case irishIreland
  case italian
  case italianItaly
  case italianSanMarino
  case italianSwitzerland
  case japanese
  case japaneseJapan
  case jolaFonyi
  case jolaFonyiSenegal
  case kabuverdianu
  case kabuverdianuCapeVerde
  case kabyle
  case kabyleAlgeria
  case kako
  case kakoCameroon
  case kalaallisut
  case kalaallisutGreenland
  case kalenjin
  case kalenjinKenya
  case kamba
  case kambaKenya
  case kannada
  case kannadaIndia
  case kashmiri
  case kashmiriArabic
  case kashmiriArabicIndia
  case kazakh
  case kazakhKazakhstan
  case khmer
  case khmerCambodia
  case kikuyu
  case kikuyuKenya
  case kinyarwanda
  case kinyarwandaRwanda
  case konkani
  case konkaniIndia
  case korean
  case koreanNorthKorea
  case koreanSouthKorea
  case koyraChiini
  case koyraChiiniMali
  case koyraboroSenni
  case koyraboroSenniMali
  case kwasio
  case kwasioCameroon
  case kyrgyz
  case kyrgyzKyrgyzstan
  case lakota
  case lakotaUnitedStates
  case langi
  case langiTanzania
  case lao
  case laoLaos
  case latvian
  case latvianLatvia
  case lingala
  case lingalaAngola
  case lingalaCentralAfricanRepublic
  case lingalaCongoBrazzaville
  case lingalaCongoKinshasa
  case lithuanian
  case lithuanianLithuania
  case lowerSorbian
  case lowerSorbianGermany
  case lubaKatanga
  case lubaKatangaCongoKinshasa
  case luo
  case luoKenya
  case luxembourgish
  case luxembourgishLuxembourg
  case luyia
  case luyiaKenya
  case macedonian
  case macedonianMacedonia
  case machame
  case machameTanzania
  case makhuwaMeetto
  case makhuwaMeettoMozambique
  case makonde
  case makondeTanzania
  case malagasy
  case malagasyMadagascar
  case malay
  case malayArabic
  case malayArabicBrunei
  case malayArabicMalaysia
  case malayBrunei
  case malayMalaysia
  case malaySingapore
  case malayalam
  case malayalamIndia
  case maltese
  case malteseMalta
  case manx
  case manxIsleOfMan
  case marathi
  case marathiIndia
  case masai
  case masaiKenya
  case masaiTanzania
  case meru
  case meruKenya
  case meta
  case metaCameroon
  case mongolian
  case mongolianMongolia
  case morisyen
  case morisyenMauritius
  case mundang
  case mundangCameroon
  case nama
  case namaNamibia
  case nepali
  case nepaliIndia
  case nepaliNepal
  case ngiemboon
  case ngiemboonCameroon
  case ngomba
  case ngombaCameroon
  case northNdebele
  case northNdebeleZimbabwe
  case northernSami
  case northernSamiFinland
  case northernSamiNorway
  case northernSamiSweden
  case norwegianBokml
  case norwegianBokmlNorway
  case norwegianBokmlSvalbardJanMayen
  case norwegianNynorsk
  case norwegianNynorskNorway
  case nuer
  case nuerSudan
  case nyankole
  case nyankoleUganda
  case oriya
  case oriyaIndia
  case oromo
  case oromoEthiopia
  case oromoKenya
  case ossetic
  case osseticGeorgia
  case osseticRussia
  case pashto
  case pashtoAfghanistan
  case persian
  case persianAfghanistan
  case persianIran
  case polish
  case polishPoland
  case portuguese
  case portugueseAngola
  case portugueseBrazil
  case portugueseCapeVerde
  case portugueseGuineaBissau
  case portugueseMacauSarChina
  case portugueseMozambique
  case portuguesePortugal
  case portugueseSoTomPrncipe
  case portugueseTimorLeste
  case punjabi
  case punjabiArabic
  case punjabiArabicPakistan
  case punjabiIndia
  case quechua
  case quechuaBolivia
  case quechuaEcuador
  case quechuaPeru
  case romanian
  case romanianMoldova
  case romanianRomania
  case romansh
  case romanshSwitzerland
  case rombo
  case romboTanzania
  case rundi
  case rundiBurundi
  case russian
  case russianBelarus
  case russianKazakhstan
  case russianKyrgyzstan
  case russianMoldova
  case russianRussia
  case russianUkraine
  case rwa
  case rwaTanzania
  case sakha
  case sakhaRussia
  case samburu
  case samburuKenya
  case sango
  case sangoCentralAfricanRepublic
  case sangu
  case sanguTanzania
  case scottishGaelic
  case scottishGaelicUnitedKingdom
  case sena
  case senaMozambique
  case serbian
  case serbianBosniaHerzegovina
  case serbianKosovo
  case serbianLatin
  case serbianLatinBosniaHerzegovina
  case serbianLatinKosovo
  case serbianLatinMontenegro
  case serbianLatinSerbia
  case serbianMontenegro
  case serbianSerbia
  case shambala
  case shambalaTanzania
  case shona
  case shonaZimbabwe
  case sichuanYi
  case sichuanYiChina
  case sinhala
  case sinhalaSriLanka
  case slovak
  case slovakSlovakia
  case slovenian
  case slovenianSlovenia
  case soga
  case sogaUganda
  case somali
  case somaliDjibouti
  case somaliEthiopia
  case somaliKenya
  case somaliSomalia
  case spanish
  case spanishArgentina
  case spanishBolivia
  case spanishCanaryIslands
  case spanishCeutaMelilla
  case spanishChile
  case spanishColombia
  case spanishCostaRica
  case spanishCuba
  case spanishDominicanRepublic
  case spanishEcuador
  case spanishElSalvador
  case spanishEquatorialGuinea
  case spanishGuatemala
  case spanishHonduras
  case spanishLatinAmerica
  case spanishMexico
  case spanishNicaragua
  case spanishPanama
  case spanishParaguay
  case spanishPeru
  case spanishPhilippines
  case spanishPuertoRico
  case spanishSpain
  case spanishUnitedStates
  case spanishUruguay
  case spanishVenezuela
  case standardMoroccanTamazight
  case standardMoroccanTamazightMorocco
  case swahili
  case swahiliCongoKinshasa
  case swahiliKenya
  case swahiliTanzania
  case swahiliUganda
  case swedish
  case swedishlandIslands
  case swedishFinland
  case swedishSweden
  case swissGerman
  case swissGermanFrance
  case swissGermanLiechtenstein
  case swissGermanSwitzerland
  case tachelhit
  case tachelhitMorocco
  case tachelhitTifinagh
  case tachelhitTifinaghMorocco
  case taita
  case taitaKenya
  case tajik
  case tajikTajikistan
  case tamil
  case tamilIndia
  case tamilMalaysia
  case tamilSingapore
  case tamilSriLanka
  case tasawaq
  case tasawaqNiger
  case telugu
  case teluguIndia
  case teso
  case tesoKenya
  case tesoUganda
  case thai
  case thaiThailand
  case tibetan
  case tibetanChina
  case tibetanIndia
  case tigrinya
  case tigrinyaEritrea
  case tigrinyaEthiopia
  case tongan
  case tonganTonga
  case turkish
  case turkishCyprus
  case turkishTurkey
  case turkmen
  case turkmenTurkmenistan
  case ukrainian
  case ukrainianUkraine
  case upperSorbian
  case upperSorbianGermany
  case urdu
  case urduIndia
  case urduPakistan
  case uyghur
  case uyghurArabic
  case uyghurArabicChina
  case uzbek
  case uzbekArabic
  case uzbekArabicAfghanistan
  case uzbekLatin
  case uzbekLatinUzbekistan
  case uzbekUzbekistan
  case vai
  case vaiLatin
  case vaiLatinLiberia
  case vaiLiberia
  case vietnamese
  case vietnameseVietnam
  case vunjo
  case vunjoTanzania
  case walser
  case walserSwitzerland
  case welsh
  case welshUnitedKingdom
  case westernFrisian
  case westernFrisianNetherlands
  case yangben
  case yangbenCameroon
  case yiddish
  case yiddishWorld
  case yoruba
  case yorubaBenin
  case yorubaNigeria
  case zarma
  case zarmaNiger
  case zulu
  case zuluSouthAfrica
  public var locale: Foundation.Locale {
    get
  }
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
extension ORKQuestionResult : MobileWorkflowCore.JSONRepresentable {
  public var jsonContent: Swift.String? {
    get
  }
}
extension ORKQuestionResult : MobileWorkflowCore.ValueProvider {
  public var content: [Swift.AnyHashable : Swift.Codable] {
    get
  }
  public func fetchProvider(for path: Swift.String) -> MobileWorkflowCore.ValueProvider?
  public func fetchValue(for path: Swift.String) -> Any?
}
public protocol SessionProvider {
}
@_hasMissingDesignatedInitializers public class Session {
  final public let fileManager: Foundation.FileManager
  final public let valueFormatter: MobileWorkflowCore.ValueFormatter
  final public let urlFormatter: MobileWorkflowCore.URLFormatter
  public var environment: MobileWorkflowCore.Server?
  public var preferredLanguage: Swift.String?
  public func fetchBinaries() -> [MobileWorkflowCore.BinaryProvider]
  public func checkAndConvertBinaries(completion: @escaping ((Swift.Error?) -> Swift.Void))
  public func fetchValue(resource: Swift.String) -> Any?
  public func resolve(value: Swift.String) -> Swift.String
  public func resolve(url: Swift.String) -> Foundation.URL?
  @objc deinit
}
extension Session : MobileWorkflowCore.JSONRepresentable {
  public var jsonContent: Swift.String? {
    get
  }
}
public enum Currency : Swift.String {
  case afghani, algerianDinar, argentinePeso, armenianDram, arubanFlorin, australianDollar, azerbaijanManat, bahamianDollar, bahrainiDinar, baht, balboa, barbadosDollar, belarusianRuble, belizeDollar, bermudianDollar, boliviano, bol√≠var, brazilianReal, bruneiDollar, bulgarianLev, burundiFranc, caboVerdeEscudo, canadianDollar, caymanIslandsDollar, chileanPeso, colombianPeso, comorianFranc, congoleseFranc, convertibleMark, cordobaOro, costaRicanColon, cubanPeso, czechKoruna, dalasi, danishKrone, denar, djiboutiFranc, dobra, dollar, dominicanPeso, dong, eastCaribbeanDollar, egyptianPound, elSalvadorColon, ethiopianBirr, euro, falklandIslandsPound, fijiDollar, forint, ghanaCedi, gibraltarPound, gourde, guarani, guineanFranc, guyanaDollar, hongKongDollar, hryvnia, icelandKrona, indianRupee, iranianRial, iraqiDinar, jamaicanDollar, jordanianDinar, kenyanShilling, kina, kuna, kuwaitiDinar, kwanza, kyat, laoKip, lari, lebanesePound, lek, lempira, leone, liberianDollar, libyanDinar, lilangeni, loti, malagasyAriary, malawiKwacha, malaysianRinggit, mauritiusRupee, mexicanPeso, mexicanUnidadDeInversion, moldovanLeu, moroccanDirham, mozambiqueMetical, mvdol, naira, nakfa, namibiaDollar, nepaleseRupee, netherlandsAntilleanGuilder, newIsraeliSheqel, newTaiwanDollar, newZealandDollar, ngultrum, northKoreanWon, norwegianKrone, ouguiya, paanga, pakistanRupee, pataca, pesoConvertible, pesoUruguayo, philippinePiso, poundSterling, pula, qatariRial, quetzal, rand, rialOmani, riel, romanianLeu, rufiyaa, rupiah, russianRuble, rwandaFranc, saintHelenaPound, saudiRiyal, serbianDinar, seychellesRupee, singaporeDollar, sol, solomonIslandsDollar, som, somaliShilling, somoni, southSudanesePound, sriLankaRupee, sudanesePound, surinamDollar, swedishKrona, swissFranc, syrianPound, taka, tala, tanzanianShilling, tenge, trinidadAndTobagoDollar, tugrik, tunisianDinar, turkishLira, turkmenistanNewManat, uaeDirham, ugandaShilling, unidadDeFomento, unidadDeValorReal, uruguayPesoEnUnidadesIndexadas, uzbekistanSum, vatu, wirEuro, wirFranc, won, yemeniRial, yen, yuanRenminbi, zambianKwacha, zimbabweDollar, zloty, none
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class AppConfigurationManager {
  convenience public init(withPlugins plugins: [MobileWorkflowCore.MobileWorkflowPlugin.Type], fileManager: Foundation.FileManager, networkService: MobileWorkflowCore.NetworkService)
  @objc deinit
}
public protocol CredentialsStoreProtocol {
  func updateCredential(_ credential: MobileWorkflowCore.Credential, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  func retrieveCredential(_ credentialType: MobileWorkflowCore.CredentialType, isRequired: Swift.Bool) -> Swift.Result<MobileWorkflowCore.Credential?, MobileWorkflowCore.CredentialError>
  func removeCredential(_ credentialType: MobileWorkflowCore.CredentialType) -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
  func wipeCredentials() -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
}
extension String {
  public func fw_attributedString(baseAttributes: [Foundation.NSAttributedString.Key : Any], substringsAttributes: [(substrings: [Swift.String], attributes: [Foundation.NSAttributedString.Key : Any])] = []) -> Foundation.NSAttributedString
  public var fw_firstCapitalized: Swift.String {
    get
  }
  public func fw_camelCaseToWords() -> Swift.String
}
public protocol CurrencyFormatting {
  var maxDigitsCount: Swift.Int { get }
  var decimalDigits: Swift.Int { get set }
  var maxValue: Swift.Double? { get set }
  var minValue: Swift.Double? { get set }
  var initialText: Swift.String { get }
  var currencySymbol: Swift.String { get set }
  func string(from doubleValue: Swift.Double) -> Swift.String?
  func unformatted(string: Swift.String) -> Swift.String?
  func double(from string: Swift.String) -> Swift.Double?
}
public protocol CurrencyAdjusting {
  func formattedStringWithAdjustedDecimalSeparator(from string: Swift.String) -> Swift.String?
  func formattedStringAdjustedToFitAllowedValues(from string: Swift.String) -> Swift.String?
}
@objc public class CurrencyFormatter : ObjectiveC.NSObject, MobileWorkflowCore.CurrencyFormatting {
  public var locale: MobileWorkflowCore.LocaleConvertible {
    get
    set
  }
  @objc public var nsLocale: Foundation.NSLocale {
    @objc get
    @objc set
  }
  public var currency: MobileWorkflowCore.Currency {
    get
    set
  }
  public var showCurrencySymbol: Swift.Bool {
    get
    set
  }
  public var currencySymbol: Swift.String {
    get
    set
  }
  public var minValue: Swift.Double? {
    get
    set
  }
  public var maxValue: Swift.Double? {
    get
    set
  }
  public var decimalDigits: Swift.Int {
    get
    set
  }
  public var hasDecimals: Swift.Bool {
    get
    set
  }
  public var decimalSeparator: Swift.String {
    get
    set
  }
  @objc public var currencyCode: Swift.String {
    @objc get
    @objc set
  }
  public var alwaysShowsDecimalSeparator: Swift.Bool {
    get
    set
  }
  public var groupingSize: Swift.Int {
    get
    set
  }
  public var secondaryGroupingSize: Swift.Int {
    get
    set
  }
  public var groupingSeparator: Swift.String {
    get
    set
  }
  public var hasGroupingSeparator: Swift.Bool {
    get
    set
  }
  public var zeroSymbol: Swift.String? {
    get
    set
  }
  public var nilSymbol: Swift.String {
    get
    set
  }
  @objc final public let numberFormatter: Foundation.NumberFormatter
  public var maxIntegers: Swift.Int? {
    get
    set
  }
  public var maxDigitsCount: Swift.Int {
    get
  }
  public var initialText: Swift.String {
    get
  }
  public typealias InitHandler = ((MobileWorkflowCore.CurrencyFormatter) -> (Swift.Void))
  @objc public init(_ handler: MobileWorkflowCore.CurrencyFormatter.InitHandler? = nil)
  @objc deinit
  @objc override dynamic public init()
}
extension CurrencyFormatter {
  @objc dynamic public func string(from doubleValue: Swift.Double) -> Swift.String?
  public func double(from string: Swift.String) -> Swift.Double?
  @objc dynamic public func doubleAsNSNumber(from string: Swift.String) -> Foundation.NSNumber?
  @objc dynamic public func unformatted(string: Swift.String) -> Swift.String?
}
extension CurrencyFormatter : MobileWorkflowCore.CurrencyAdjusting {
  public func formattedStringWithAdjustedDecimalSeparator(from string: Swift.String) -> Swift.String?
  public func formattedStringAdjustedToFitAllowedValues(from string: Swift.String) -> Swift.String?
}
extension ORKChoiceQuestionResult : MobileWorkflowCore.NavigationTriggerResult {
  public var navigationDestinationKey: Swift.String? {
    get
  }
}
public enum BinaryContentType {
  public enum Image {
    public static let heif: Swift.String
    public static let jpeg: Swift.String
  }
  public enum Video {
    public static let mp4: Swift.String
  }
  public enum Application {
    public static let pdf: Swift.String
  }
}
extension ORKFileResult : MobileWorkflowCore.BinaryProvider {
  public var binaryIdentifier: Swift.String {
    get
  }
  public var cachePath: Swift.String? {
    get
  }
  public var fileName: Swift.String? {
    get
  }
  public var fileType: Swift.String? {
    get
  }
  public func load(using fileManager: Foundation.FileManager) -> Foundation.Data?
}
final public class CredentialsStore : MobileWorkflowCore.CredentialsStoreProtocol {
  public init(securityStore: MobileWorkflowCore.SecurityStoreProtocol = SecurityStore())
  final public func updateCredential(_ credential: MobileWorkflowCore.Credential, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  final public func saveCredential(_ credential: MobileWorkflowCore.Credential, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  final public func removeCredential(_ credentialType: MobileWorkflowCore.CredentialType) -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
  final public func retrieveCredential(_ credentialType: MobileWorkflowCore.CredentialType, isRequired: Swift.Bool) -> Swift.Result<MobileWorkflowCore.Credential?, MobileWorkflowCore.CredentialError>
  final public func wipeCredentials() -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
  @objc deinit
}
public struct ValueFormatter {
  public static let DefaultValueComposerRegex: Swift.String
  public init(regex: Swift.String = DefaultValueComposerRegex)
  public func parse(valueString: Swift.String, using session: MobileWorkflowCore.Session?) -> Swift.String?
}
public protocol ImageLoadingService {
  func syncLoad(image: Swift.String) -> UIKit.UIImage?
  func asyncLoad(image: Swift.String, completion: ((UIKit.UIImage?) -> Swift.Void)?) -> Combine.AnyCancellable?
}
extension UITextField {
  public var selectedTextRangeOffsetFromEnd: Swift.Int {
    get
  }
  public func setInitialSelectedTextRange()
  public func updateSelectedTextRange(lastOffsetFromEnd: Swift.Int)
}
@objc @_hasMissingDesignatedInitializers public class MobileWorkflowRootViewController : UIKit.UIViewController, MobileWorkflowCore.ORKTaskViewControllerDelegate {
  public init(manager: MobileWorkflowCore.AppConfigurationManager, preferredConfigurations: [MobileWorkflowCore.AppConfigurationContext] = [])
  @objc override dynamic public func viewDidLoad()
  public func loadAppConfiguration(_ context: MobileWorkflowCore.AppConfigurationContext)
  @objc public func taskViewController(_ taskViewController: MobileWorkflowCore.ORKTaskViewController, didFinishWith reason: MobileWorkflowCore.ORKTaskViewControllerFinishReason, error: Swift.Error?)
  @objc public func taskViewController(_ taskViewController: MobileWorkflowCore.ORKTaskViewController, stepViewControllerWillAppear stepViewController: MobileWorkflowCore.ORKStepViewController)
  @objc public func taskViewController(_ taskViewController: MobileWorkflowCore.ORKTaskViewController, stepViewControllerWillDisappear stepViewController: MobileWorkflowCore.ORKStepViewController, navigationDirection direction: MobileWorkflowCore.ORKStepViewControllerNavigationDirection)
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
public protocol CurrencyString {
  var representsZero: Swift.Bool { get }
  var hasNumbers: Swift.Bool { get }
  var lastNumberOffsetFromEnd: Swift.Int? { get }
  func numeralFormat() -> Swift.String
  mutating func updateDecimalSeparator(decimalDigits: Swift.Int)
}
extension String : MobileWorkflowCore.CurrencyString {
  public var representsZero: Swift.Bool {
    get
  }
  public var hasNumbers: Swift.Bool {
    get
  }
  public var lastNumberOffsetFromEnd: Swift.Int? {
    get
  }
  public mutating func updateDecimalSeparator(decimalDigits: Swift.Int)
  public func numeralFormat() -> Swift.String
}
extension String {
  public static let negativeSymbol: Swift.String
}
public protocol NavigationTriggerResult {
  var navigationDestinationKey: Swift.String? { get }
}
public typealias Parse<T> = (Foundation.Data) throws -> T
public typealias ParsePublisher<T> = (Combine.AnyPublisher<Foundation.Data, Swift.Error>) -> Combine.AnyPublisher<T, Swift.Error>
extension Decodable {
  public static func decodeParse(decoder: Foundation.JSONDecoder = JSONDecoder()) -> MobileWorkflowCore.Parse<Self>
  public static func parsePublisher(_ parse: @escaping MobileWorkflowCore.Parse<Self> = Self.decodeParse()) -> MobileWorkflowCore.ParsePublisher<Self>
}
public protocol RemoteContentStepViewController : UIKit.UIViewController, MobileWorkflowCore.WorkflowPresentationDelegator {
  associatedtype StepType : MobileWorkflowCore.RemoteContentStep
  var remoteContentStep: Self.StepType! { get }
  var showBadURLError: Swift.Bool { get }
  func loadContent()
  func showLoading()
  func hideLoading()
  func update(content: Self.StepType.ResponseType)
}
extension RemoteContentStepViewController {
  public var showBadURLError: Swift.Bool {
    get
  }
}
extension RemoteContentStepViewController where Self.StepType.ResponseType : Swift.Decodable {
  public func loadContent()
}
extension UIFont {
  public static func preferredFont(forTextStyle style: UIKit.UIFont.TextStyle, weight: UIKit.UIFont.Weight) -> UIKit.UIFont
}
extension ORKPredicateStepNavigationRule {
  convenience public init(resultPredicatesAndDestinationStepIdentifiers tuples: [(resultPredicate: Foundation.NSPredicate, destinationStepIdentifier: Swift.String)], defaultStepIdentifierOrNil: Swift.String? = nil)
}
public enum HTTPMethod : Swift.String {
  case get
  case head
  case post
  case put
  case delete
  case connect
  case options
  case trace
  case patch
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
}
@objc @_inheritsConvenienceInitializers public class CurrencyUITextFieldDelegate : ObjectiveC.NSObject {
  public var formatter: (MobileWorkflowCore.CurrencyAdjusting & MobileWorkflowCore.CurrencyFormatting)!
  public var clearsWhenValueIsZero: Swift.Bool
  @objc public var passthroughDelegate: UIKit.UITextFieldDelegate? {
    @objc get
    @objc set
  }
  @objc override dynamic public init()
  @objc public init(formatter: MobileWorkflowCore.CurrencyFormatter)
  @objc deinit
}
extension CurrencyUITextFieldDelegate : UIKit.UITextFieldDelegate {
  @discardableResult
  @objc dynamic open func textFieldShouldBeginEditing(_ textField: UIKit.UITextField) -> Swift.Bool
  @objc dynamic public func textFieldDidBeginEditing(_ textField: UIKit.UITextField)
  @discardableResult
  @objc dynamic public func textFieldShouldEndEditing(_ textField: UIKit.UITextField) -> Swift.Bool
  @objc dynamic open func textFieldDidEndEditing(_ textField: UIKit.UITextField)
  @discardableResult
  @objc dynamic open func textFieldShouldClear(_ textField: UIKit.UITextField) -> Swift.Bool
  @discardableResult
  @objc dynamic open func textFieldShouldReturn(_ textField: UIKit.UITextField) -> Swift.Bool
  @discardableResult
  @objc dynamic public func textField(_ textField: UIKit.UITextField, shouldChangeCharactersIn range: Foundation.NSRange, replacementString string: Swift.String) -> Swift.Bool
}
public protocol MobileWorkflowPlugin {
  static var allStepsTypes: [MobileWorkflowCore.MobileWorkflowStepType] { get }
}
public protocol MobileWorkflowStepType : MobileWorkflowCore.StepType {
  var stepClass: MobileWorkflowCore.MobileWorkflowStep.Type { get }
}
public protocol MobileWorkflowStep : MobileWorkflowCore.BuildableStep {
}
public protocol StepType {
  var typeName: Swift.String { get }
}
public struct StepContext {
  public let appName: Swift.String?
  public let workflowName: Swift.String?
  public let systemTintColor: UIKit.UIColor
}
public struct StepInfo {
  public let data: MobileWorkflowCore.StepData
  public let context: MobileWorkflowCore.StepContext
}
public struct StepData : Swift.Codable {
  public let type: Swift.String
  public let identifier: Swift.String
  public let uuid: Swift.String
  public let image: UIKit.UIImage?
  public let imageURL: Swift.String?
  public let content: [Swift.String : Any]
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@objc @_hasMissingDesignatedInitializers public class MessageStateView : UIKit.UIView {
  public init(frame: CoreGraphics.CGRect, message: Swift.String)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class LoadingStateView : UIKit.UIView {
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
extension ORKSignatureResult : MobileWorkflowCore.BinaryProvider {
  public var binaryIdentifier: Swift.String {
    get
  }
  public var cachePath: Swift.String? {
    get
  }
  public var fileName: Swift.String? {
    get
  }
  public var fileType: Swift.String? {
    get
  }
  public func load(using fileManager: Foundation.FileManager) -> Foundation.Data?
}
extension UIColor {
  public func adjustedColorForBestContrast(withColor otherColor: UIKit.UIColor) -> UIKit.UIColor
}
extension ORKImageCaptureStep : MobileWorkflowCore.MobileWorkflowStep {
  public static func build(step: MobileWorkflowCore.StepInfo, services: MobileWorkflowCore.MobileWorkflowServices) throws -> MobileWorkflowCore.ORKStep
}
public enum AppConfigurationContext {
  case remote(url: Swift.String, serverId: Swift.Int?)
  case cached
  case file(path: Swift.String, serverId: Swift.Int?, workflowId: Swift.Int?, sessionValues: [Swift.String : Any]? = nil)
}
extension Collection where Self.Element == MobileWorkflowCore.URLSchemeManager {
  public func firstValidConfiguration(from urlContexts: Swift.Set<UIKit.UIOpenURLContext>) -> MobileWorkflowCore.AppConfigurationContext?
}
public protocol NetworkService {
  func request<T>(url: Swift.String, httpMethod: MobileWorkflowCore.HTTPMethod, using session: MobileWorkflowCore.Session, requiresAuthentication: Swift.Bool, parsePublisher: @escaping MobileWorkflowCore.ParsePublisher<T>, completionQueue: Dispatch.DispatchQueue, completion: @escaping (Swift.Result<T, Swift.Error>) -> Swift.Void) -> Combine.AnyCancellable?
  func postSession(to url: Swift.String, using session: MobileWorkflowCore.Session, completionQueue: Dispatch.DispatchQueue, completion: @escaping (Swift.Result<Foundation.Data, Swift.Error>) -> Swift.Void) -> Combine.AnyCancellable?
  func upload(urls: [MobileWorkflowCore.NetworkStepBinaryResponse], using session: MobileWorkflowCore.Session, completionQueue: Dispatch.DispatchQueue, completion: @escaping (MobileWorkflowCore.FileUploadUpdate) -> Swift.Void) -> Combine.AnyCancellable?
  func authenticateWithProvider(_ authProvider: MobileWorkflowCore.AuthProvider, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
}
public struct LocalizationService {
  public func translate(_ stringToTranslate: Swift.String?) -> Swift.String?
}
public struct NetworkStepBinaryResponse : Swift.Codable {
  public let identifier: Swift.String
  public let url: Swift.String
  public let method: Swift.String
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum CredentialError : Swift.Error {
  case invalidInputData
  case storingError
  case requiredButNotFound
  case unexpected
  public static func == (a: MobileWorkflowCore.CredentialError, b: MobileWorkflowCore.CredentialError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct Server : Swift.Codable {
  public let id: Swift.Int
  public let url: Foundation.URL
  public init(id: Swift.Int, url: Foundation.URL)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol ValueProvider : MobileWorkflowCore.SessionProvider {
  var content: [Swift.AnyHashable : Swift.Codable] { get }
  func fetchValue(for path: Swift.String) -> Any?
  func fetchProvider(for path: Swift.String) -> MobileWorkflowCore.ValueProvider?
}
extension String : MobileWorkflowCore.ValueProvider {
  public var content: [Swift.AnyHashable : Swift.Codable] {
    get
  }
  public func fetchValue(for path: Swift.String) -> Any?
  public func fetchProvider(for path: Swift.String) -> MobileWorkflowCore.ValueProvider?
}
extension Dictionary : MobileWorkflowCore.SessionProvider {
}
extension Dictionary : MobileWorkflowCore.ValueProvider where Key == Swift.String {
  public var content: [Swift.AnyHashable : Swift.Codable] {
    get
  }
  public func fetchValue(for path: Swift.String) -> Any?
  public func fetchProvider(for path: Swift.String) -> MobileWorkflowCore.ValueProvider?
}
public enum SyncResult {
  case alreadyInSync
  case didSync
  public static func == (a: MobileWorkflowCore.SyncResult, b: MobileWorkflowCore.SyncResult) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol SyncableContentSource : AnyObject {
  var resolvedURL: Foundation.URL? { get set }
  func syncContentSource() -> MobileWorkflowCore.SyncResult
}
extension SyncableContentSource where Self : MobileWorkflowCore.RemoteContentStep {
  public func syncContentSource() -> MobileWorkflowCore.SyncResult
}
public protocol ContentClearable {
  func clearContent()
}
extension RemoteContentStepViewController where Self : MobileWorkflowCore.ContentClearable, Self.StepType : MobileWorkflowCore.SyncableContentSource {
  public func resyncContent()
}
public enum ViewOrder {
  case top
  case above(view: UIKit.UIView)
  case below(view: UIKit.UIView)
}
extension UIView {
  public func addPinnedSubview(_ view: UIKit.UIView, order: MobileWorkflowCore.ViewOrder = .top, horizontalLayoutGuide: UIKit.UILayoutGuide? = nil, verticalLayoutGuide: UIKit.UILayoutGuide? = nil, insets: UIKit.NSDirectionalEdgeInsets = .zero)
}
extension NumberFormatter {
  public func string(from doubleValue: Swift.Double?) -> Swift.String?
}
public struct AuthRedirectHandler {
  public init(_ handler: @escaping (MobileWorkflowCore.AuthFlowResumer) -> Swift.Void)
}
public protocol AuthProvider {
  func authenticate(completion: @escaping (Swift.Result<MobileWorkflowCore.Credential, Swift.Error>) -> Swift.Void) -> MobileWorkflowCore.AuthFlowResumer
}
public class AuthProviderImplementation : MobileWorkflowCore.AuthProvider {
  public init(_ start: @escaping (@escaping (Swift.Result<MobileWorkflowCore.Credential, Swift.Error>) -> Swift.Void) -> MobileWorkflowCore.AuthFlowResumer)
  public func authenticate(completion: @escaping (Swift.Result<MobileWorkflowCore.Credential, Swift.Error>) -> Swift.Void) -> MobileWorkflowCore.AuthFlowResumer
  @objc deinit
}
public protocol AuthFlowResumer : AnyObject {
  func resumeAuth(with url: Foundation.URL) -> Swift.Bool
}
public protocol AuthRedirector : AnyObject {
  var authFlowResumer: MobileWorkflowCore.AuthFlowResumer? { get set }
}
extension AuthRedirector {
  public func authRedirectHandler() -> MobileWorkflowCore.AuthRedirectHandler
  public func handleAuthRedirect(for url: Foundation.URL) -> Swift.Bool
}
extension MobileWorkflowCore.CredentialType : Swift.Equatable {}
extension MobileWorkflowCore.CredentialType : Swift.Hashable {}
extension MobileWorkflowCore.CredentialType : Swift.RawRepresentable {}
extension MobileWorkflowCore.CurrencyLocale : Swift.Equatable {}
extension MobileWorkflowCore.CurrencyLocale : Swift.Hashable {}
extension MobileWorkflowCore.CurrencyLocale : Swift.RawRepresentable {}
extension MobileWorkflowCore.Currency : Swift.Equatable {}
extension MobileWorkflowCore.Currency : Swift.Hashable {}
extension MobileWorkflowCore.Currency : Swift.RawRepresentable {}
extension MobileWorkflowCore.HTTPMethod : Swift.Equatable {}
extension MobileWorkflowCore.HTTPMethod : Swift.Hashable {}
extension MobileWorkflowCore.HTTPMethod : Swift.RawRepresentable {}
extension MobileWorkflowCore.CredentialError : Swift.Equatable {}
extension MobileWorkflowCore.CredentialError : Swift.Hashable {}
extension MobileWorkflowCore.SyncResult : Swift.Equatable {}
extension MobileWorkflowCore.SyncResult : Swift.Hashable {}
