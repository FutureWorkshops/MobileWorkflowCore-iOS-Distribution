// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name MobileWorkflowCore
import AVFoundation
import AVKit
import AuthenticationServices
import SystemConfiguration.CaptiveNetwork
import Combine
import CoreLocation
import CryptoKit
import Foundation
import MediaPlayer
import MessageUI
@_exported import MobileWorkflowCore
import PDFKit
import Security
import Swift
import SystemConfiguration
import UIKit
import VisionKit
public protocol EmailStep {
  var body: Swift.String? { get }
  var subject: Swift.String { get }
  var sendTo: Swift.String? { get }
  var requestPropertyIdentifiers: [Swift.String] { get }
  var session: MobileWorkflowCore.Session { get }
  var services: MobileWorkflowCore.MobileWorkflowServices { get }
}
@objc @_hasMissingDesignatedInitializers public class MobileWorkflowEmailStep : MobileWorkflowCore.ORKStep, MobileWorkflowCore.EmailStep {
  final public let body: Swift.String?
  final public let subject: Swift.String
  final public let sendTo: Swift.String?
  final public let requestPropertyIdentifiers: [Swift.String]
  final public let session: MobileWorkflowCore.Session
  final public let services: MobileWorkflowCore.MobileWorkflowServices
  public init(identifier: Swift.String, body: Swift.String?, subject: Swift.String, sendTo: Swift.String?, requestPropertyIdentifiers: [Swift.String], session: MobileWorkflowCore.Session, services: MobileWorkflowCore.MobileWorkflowServices)
  @objc override dynamic public func stepViewControllerClass() -> Swift.AnyClass
  @objc deinit
  @objc override dynamic public init(identifier: Swift.String)
}
extension MobileWorkflowEmailStep : MobileWorkflowCore.MobileWorkflowStep {
  public static func build(step: MobileWorkflowCore.StepInfo, services: MobileWorkflowCore.MobileWorkflowServices) throws -> MobileWorkflowCore.ORKStep
}
extension StepContext {
  public var asEmailSubject: Swift.String {
    get
  }
}
public enum ParseError : Foundation.LocalizedError, Swift.CustomStringConvertible {
  case invalidStepData(cause: Swift.String)
  case invalidWorkflowData(cause: Swift.String)
  case invalidServerData(cause: Swift.String)
  case invalidAppName(cause: Swift.String)
  case invalidAppData(cause: Swift.String)
  case invalidNavigationStyle(cause: Swift.String)
  case invalidNavigationRule(cause: Swift.String)
  public var domain: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var description: Swift.String {
    get
  }
}
public struct AppConfigurationDependencies {
  public var plugins: [MobileWorkflowCore.MobileWorkflowPlugin.Type]
  public var fileManager: Foundation.FileManager
  public var credentialStore: MobileWorkflowCore.CredentialStoreProtocol?
  public var eventService: MobileWorkflowCore.EventService
  public var asyncServices: [MobileWorkflowCore.AsyncTaskService]
  public var queueController: MobileWorkflowCore.QueueControllerNetworkAsyncTaskService?
  public init(plugins: [MobileWorkflowCore.MobileWorkflowPlugin.Type], fileManager: Foundation.FileManager, credentialStore: MobileWorkflowCore.CredentialStoreProtocol?, eventService: MobileWorkflowCore.EventService, asyncServices: [MobileWorkflowCore.AsyncTaskService], queueController: MobileWorkflowCore.QueueControllerNetworkAsyncTaskService?)
  public static func `default`(withPlugins plugins: [MobileWorkflowCore.MobileWorkflowPlugin.Type], eventDelegator: MobileWorkflowCore.AppEventDelegator?, queueControllerProvider: MobileWorkflowCore.QueueControllerProvider?) -> MobileWorkflowCore.AppConfigurationDependencies
}
@objc public protocol StreamProvider {
  @objc func inputStreamFor(fileAtPath path: Swift.String) -> Foundation.InputStream?
  @objc func outputStreamFor(fileAtPath path: Swift.String, append: Swift.Bool) -> Foundation.OutputStream?
}
extension FileManager {
  @objc(mw_sharedManager) public static var shared: Foundation.FileManager
  @objc(mw_streamProvider) public static var streamProvider: MobileWorkflowCore.StreamProvider
}
extension FileManager : MobileWorkflowCore.StreamProvider {
  @objc dynamic open func inputStreamFor(fileAtPath path: Swift.String) -> Foundation.InputStream?
  @objc dynamic open func outputStreamFor(fileAtPath path: Swift.String, append: Swift.Bool) -> Foundation.OutputStream?
}
public struct MobileWorkflowServices {
  public let credentialStore: MobileWorkflowCore.CredentialStoreProtocol
  public let imageLoadingService: MobileWorkflowCore.ImageLoadingService
  public let localizationService: MobileWorkflowCore.LocalizationService
  public let eventService: MobileWorkflowCore.EventService
  public func perform<T>(task: T, session: MobileWorkflowCore.Session, completion: @escaping (Swift.Result<T.Response, Swift.Error>) -> Swift.Void) where T : MobileWorkflowCore.AsyncTask
}
public protocol StringConvertableValue {
  var stringValue: Swift.String { get }
}
extension String : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension NSString : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension Date : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension NSDate : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension Bool : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension NSNumber : MobileWorkflowCore.StringConvertableValue {
}
extension CLLocation : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension CLLocationCoordinate2D : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension Int : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension Float : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension Double : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension ORKLocation : MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
extension Array : MobileWorkflowCore.StringConvertableValue where Element == MobileWorkflowCore.StringConvertableValue {
  public var stringValue: Swift.String {
    get
  }
}
public protocol URLSchemeManager {
  func parse(url: Foundation.URL) -> MobileWorkflowCore.AppConfigurationContext?
}
public struct MobileWorkflowSchemeManager : MobileWorkflowCore.URLSchemeManager {
  public init(version: Swift.String = "v1", debugHost: Swift.String = "localhost", defaultPort: Swift.Int = 5000)
  public func parse(url: Foundation.URL) -> MobileWorkflowCore.AppConfigurationContext?
}
extension UIViewController {
  public func show(_ error: Swift.Error, actionHandler: (() -> Swift.Void)? = nil)
  public func showConfirmationAlert(title: Swift.String, message: Swift.String?, cancelTitle: Swift.String? = nil, confirmTitle: Swift.String? = nil, isDestructive: Swift.Bool = false, actionHandler: @escaping (Swift.Bool) -> Swift.Void)
}
extension UIViewController {
  public func addCovering(childViewController: UIKit.UIViewController)
}
extension UIViewController {
  public func performSystemAction(_ systemAction: MobileWorkflowCore.SystemAction) throws
}
extension UIViewController {
  public func showFilterSheet(options: [Swift.String], ascendingActionHandler: ((Swift.String) -> Swift.Void)? = nil, descendingActionHandler: ((Swift.String) -> Swift.Void)? = nil, resetHandler: (() -> Swift.Void)? = nil, cancelHandler: ((UIKit.UIAlertAction) -> Swift.Void)? = nil)
}
public protocol RemoteContentStep {
  associatedtype ResponseType
  var stepContext: MobileWorkflowCore.StepContext { get }
  var session: MobileWorkflowCore.Session { get }
  var services: MobileWorkflowCore.MobileWorkflowServices { get }
  var contentURL: Swift.String? { get }
  func loadContent(completion: @escaping (Swift.Result<Self.ResponseType, Swift.Error>) -> Swift.Void)
}
extension RemoteContentStep where Self.ResponseType : Swift.Decodable {
  public func perform<T>(url: Swift.String, method: MobileWorkflowCore.HTTPMethod, completion: @escaping (Swift.Result<T, Swift.Error>) -> Swift.Void) where T : Swift.Decodable
}
@objc @_inheritsConvenienceInitializers open class MobileWorkflowSceneDelegate : UIKit.UIResponder, UIKit.UIWindowSceneDelegate {
  @objc public var window: UIKit.UIWindow?
  public var urlSchemeManagers: [MobileWorkflowCore.URLSchemeManager]
  public var dependencies: MobileWorkflowCore.AppConfigurationDependencies
  public var rootViewController: MobileWorkflowCore.MobileWorkflowRootViewController!
  public var bundleJSONPath: Swift.String?
  @objc open func scene(_ scene: UIKit.UIScene, willConnectTo session: UIKit.UISceneSession, options connectionOptions: UIKit.UIScene.ConnectionOptions)
  @objc open func scene(_ scene: UIKit.UIScene, openURLContexts URLContexts: Swift.Set<UIKit.UIOpenURLContext>)
  open func preferredConfigurations(urlContexts: Swift.Set<UIKit.UIOpenURLContext>) -> [MobileWorkflowCore.AppConfigurationContext]
  @objc deinit
  @objc override dynamic public init()
}
public protocol JSONRepresentable {
  var jsonContent: Swift.String? { get }
}
extension Date : MobileWorkflowCore.JSONRepresentable {
  public var jsonContent: Swift.String? {
    get
  }
}
extension NSDate : MobileWorkflowCore.JSONRepresentable {
  public var jsonContent: Swift.String? {
    get
  }
}
extension CLLocation : MobileWorkflowCore.JSONRepresentable {
  public var jsonContent: Swift.String? {
    get
  }
}
extension CLLocationCoordinate2D : MobileWorkflowCore.JSONRepresentable {
  public var jsonContent: Swift.String? {
    get
  }
}
extension ORKLocation : MobileWorkflowCore.JSONRepresentable {
  public var jsonContent: Swift.String? {
    get
  }
}
public protocol BuildableStep : MobileWorkflowCore.ORKStep {
  static func build(step: MobileWorkflowCore.StepInfo, services: MobileWorkflowCore.MobileWorkflowServices) throws -> MobileWorkflowCore.ORKStep
}
@objc @_inheritsConvenienceInitializers open class MobileWorkflowButtonViewController : MobileWorkflowCore.ORKStepViewController {
  public struct ButtonConfig {
    public init(title: Swift.String, action: @escaping () -> Swift.Void)
  }
  public func configureWithTitle(_ title: Swift.String, body: Swift.String, buttonTitle: Swift.String, buttonAction: @escaping (() -> Swift.Void))
  public func configureWithTitle(_ title: Swift.String, body: Swift.String, primaryConfig: MobileWorkflowCore.MobileWorkflowButtonViewController.ButtonConfig, secondaryConfig: MobileWorkflowCore.MobileWorkflowButtonViewController.ButtonConfig?)
  @objc override dynamic public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  public func showLoading()
  public func hideLoading()
  @objc deinit
  @objc override dynamic public init(step: MobileWorkflowCore.ORKStep?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public enum FileUploadUpdate {
  case failed(error: Swift.Error)
  case uploaded(identifier: Swift.String)
  case completed
}
public enum LocationServiceError : Foundation.LocalizedError {
  case significantLocationChangeMonitoringUnavailable
  public var errorDescription: Swift.String? {
    get
  }
  public var localizedDescription: Swift.String {
    get
  }
  public static func == (a: MobileWorkflowCore.LocationServiceError, b: MobileWorkflowCore.LocationServiceError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@objc public class LocationService : ObjectiveC.NSObject {
  public init(userDefaults: Foundation.UserDefaults = .standard)
  public func significantLocationChangesPublisher() -> Combine.AnyPublisher<[CoreLocation.CLLocation], Swift.Error>
  @objc deinit
  @objc override dynamic public init()
}
extension LocationService : CoreLocation.CLLocationManagerDelegate {
  @objc dynamic public func locationManager(_ manager: CoreLocation.CLLocationManager, didUpdateLocations locations: [CoreLocation.CLLocation])
  @objc dynamic public func locationManager(_ manager: CoreLocation.CLLocationManager, didFailWithError error: Swift.Error)
}
@objc @_inheritsConvenienceInitializers public class QueueControllerNetworkAsyncTaskService : ObjectiveC.NSObject {
  public static let kQueuedSessionIdentifier: Swift.String
  public enum Exceptions : Swift.Error {
    case ItemEnqueued
    public static func == (a: MobileWorkflowCore.QueueControllerNetworkAsyncTaskService.Exceptions, b: MobileWorkflowCore.QueueControllerNetworkAsyncTaskService.Exceptions) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  @objc convenience override dynamic public init()
  required public init(sessionIdentifier: Swift.String = QueueControllerNetworkAsyncTaskService.kQueuedSessionIdentifier, configuration: MobileWorkflowCore.QueueControllerConfiguration = .disabled, credentialStore: MobileWorkflowCore.CredentialStore = CredentialStore(), shadowNetworkService: MobileWorkflowCore.AsyncTaskService? = nil, reachability: MobileWorkflowCore.Reachability = Reachability())
  @discardableResult
  public func handleEvents(sessionIdentifier: Swift.String, completion: @escaping () -> Swift.Void) -> Swift.Bool
  public func loadConfiguration(configuration: MobileWorkflowCore.ServiceConfiguration)
  public func updateShadowNetworkService(shadowNetworkService: MobileWorkflowCore.AsyncTaskService)
  public func updateCredentialStore(credentialStore: MobileWorkflowCore.CredentialStoreProtocol)
  @objc deinit
}
extension QueueControllerNetworkAsyncTaskService : MobileWorkflowCore.AsyncTaskService {
  public func canPerform<T>(task: T) -> Swift.Bool where T : MobileWorkflowCore.AsyncTask
  public func perform<T>(task: T, session: MobileWorkflowCore.ContentProvider, respondOn: Dispatch.DispatchQueue, completion: @escaping (Swift.Result<T.Response, Swift.Error>) -> Swift.Void) where T : MobileWorkflowCore.AsyncTask
}
public class AuthenticationService : MobileWorkflowCore.AsyncTaskService {
  public init(credentialStore: MobileWorkflowCore.CredentialStoreProtocol, authRedirectHandler: MobileWorkflowCore.AuthRedirectHandler?)
  public func canPerform<T>(task: T) -> Swift.Bool where T : MobileWorkflowCore.AsyncTask
  public func perform<T>(task: T, session: MobileWorkflowCore.ContentProvider, respondOn: Dispatch.DispatchQueue, completion: @escaping (Swift.Result<T.Response, Swift.Error>) -> Swift.Void) where T : MobileWorkflowCore.AsyncTask
  @objc deinit
}
public struct LocationUploadServiceConfiguration : Swift.Codable {
  public let id: Swift.String
  public let url: Swift.String
  public let method: Swift.String
  public init(from decoder: Swift.Decoder) throws
  public init(id: Swift.String, properties: [Swift.String : Any]) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol BinaryProvider : MobileWorkflowCore.SessionProvider {
  var binaryIdentifier: Swift.String { get }
  var cachePath: Swift.String? { get }
  var fileName: Swift.String? { get }
  var fileType: Swift.String? { get }
  var fileURL: Foundation.URL? { get }
  var contentType: Swift.String? { get }
  func load(using fileManager: Foundation.FileManager) -> Foundation.Data?
}
extension BinaryProvider {
  public func load(using fileManager: Foundation.FileManager) -> Foundation.Data?
}
public struct AuthenticationTask : MobileWorkflowCore.AsyncTask {
  public typealias Response = Swift.Void
  public let input: MobileWorkflowCore.AuthProvider
  public init(input: MobileWorkflowCore.AuthProvider)
  public typealias Input = MobileWorkflowCore.AuthProvider
}
public enum WorkflowPresentationError : Foundation.LocalizedError {
  case workflowNotFound(name: Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public var localizedDescription: Swift.String {
    get
  }
}
public typealias OnWorkflowDismiss = (MobileWorkflowCore.WorkflowFinishReason) -> Swift.Void
public protocol WorkflowPresentationDelegate : AnyObject {
  func presentWorkflowWithName(_ name: Swift.String, isDiscardable: Swift.Bool, animated: Swift.Bool, onDismiss: MobileWorkflowCore.OnWorkflowDismiss?)
  func presentWorkflowWithId(_ id: Swift.String, isDiscardable: Swift.Bool, animated: Swift.Bool, onDismiss: MobileWorkflowCore.OnWorkflowDismiss?)
}
public protocol WorkflowPresentationDelegator : AnyObject {
  var workflowPresentationDelegate: MobileWorkflowCore.WorkflowPresentationDelegate? { get set }
}
public protocol PresentedWorkflow : AnyObject {
  var onDismiss: MobileWorkflowCore.OnWorkflowDismiss? { get }
}
public enum CredentialType : Swift.String, Swift.CaseIterable {
  case token
  case refreshToken
  case appleIdCredentialUser
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [MobileWorkflowCore.CredentialType]
  public static var allCases: [MobileWorkflowCore.CredentialType] {
    get
  }
}
public protocol MobileWorkflowButtonTableViewCellDelegate : AnyObject {
  func buttonCell(_ cell: MobileWorkflowCore.MobileWorkflowButtonTableViewCell, didTapButton button: UIKit.UIButton)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class MobileWorkflowButtonTableViewCell : UIKit.UITableViewCell {
  public var delegate: MobileWorkflowCore.MobileWorkflowButtonTableViewCellDelegate?
  public func configureButton(label: Swift.String?, style: MobileWorkflowCore.ButtonStyle)
  @objc deinit
}
public struct URLFormatter {
  public static let DefaultURLComposerRegex: Swift.String
  public init(regex: Swift.String = DefaultURLComposerRegex)
  public func parse(baseURL: Foundation.URL, complement: Swift.String, using session: MobileWorkflowCore.ContentProvider?) -> Foundation.URL?
}
public struct Credential : Swift.Codable {
  public let type: Swift.String
  public let value: Swift.String
  public let expirationDate: Foundation.Date
  public init(type: Swift.String, value: Swift.String, expirationDate: Foundation.Date)
  public var credentialType: MobileWorkflowCore.CredentialType? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol QueueableTask {
  var type: Swift.String { get }
  func encode(encoder: Foundation.JSONEncoder) throws -> Foundation.Data
  static func decode(decoder: Foundation.JSONDecoder, data: Foundation.Data) throws -> Self
}
public protocol SecurityStoreProtocol {
  func storePassword(key: Swift.String, value: Foundation.Data) -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
  func password(for key: Swift.String) -> Swift.Result<Foundation.Data?, MobileWorkflowCore.CredentialError>
  func removePassword(key: Swift.String) -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
}
public protocol AsyncTask {
  associatedtype Response
  associatedtype Input
  var input: Self.Input { get }
}
public protocol Credentialized {
  var credential: MobileWorkflowCore.Credential? { get }
}
public protocol CredentializedAsyncTask : MobileWorkflowCore.AsyncTask, MobileWorkflowCore.Credentialized {
}
final public class SecurityStore : MobileWorkflowCore.SecurityStoreProtocol {
  public init()
  final public func storePassword(key: Swift.String, value: Foundation.Data) -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
  final public func password(for key: Swift.String) -> Swift.Result<Foundation.Data?, MobileWorkflowCore.CredentialError>
  final public func removePassword(key: Swift.String) -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
  @objc deinit
}
public protocol LocaleConvertible {
  var locale: Foundation.Locale { get }
}
extension Locale : MobileWorkflowCore.LocaleConvertible {
  public var locale: Foundation.Locale {
    get
  }
}
public enum CurrencyLocale : Swift.String, MobileWorkflowCore.LocaleConvertible {
  case current
  case autoUpdating
  case afrikaans
  case afrikaansNamibia
  case afrikaansSouthAfrica
  case aghem
  case aghemCameroon
  case akan
  case akanGhana
  case albanian
  case albanianAlbania
  case albanianKosovo
  case albanianMacedonia
  case amharic
  case amharicEthiopia
  case arabic
  case arabicAlgeria
  case arabicBahrain
  case arabicChad
  case arabicComoros
  case arabicDjibouti
  case arabicEgypt
  case arabicEritrea
  case arabicIraq
  case arabicIsrael
  case arabicJordan
  case arabicKuwait
  case arabicLebanon
  case arabicLibya
  case arabicMauritania
  case arabicMorocco
  case arabicOman
  case arabicPalestinianTerritories
  case arabicQatar
  case arabicSaudiArabia
  case arabicSomalia
  case arabicSouthSudan
  case arabicSudan
  case arabicSyria
  case arabicTunisia
  case arabicUnitedArabEmirates
  case arabicWesternSahara
  case arabicWorld
  case arabicYemen
  case armenian
  case armenianArmenia
  case assamese
  case assameseIndia
  case asu
  case asuTanzania
  case azerbaijani
  case azerbaijaniAzerbaijan
  case azerbaijaniCyrillic
  case azerbaijaniCyrillicAzerbaijan
  case bafia
  case bafiaCameroon
  case bambara
  case bambaraMali
  case basaa
  case basaaCameroon
  case basque
  case basqueSpain
  case belarusian
  case belarusianBelarus
  case bemba
  case bembaZambia
  case bena
  case benaTanzania
  case bengali
  case bengaliBangladesh
  case engaliIndia
  case bodo
  case bodoIndia
  case bosnian
  case bosnianBosniaHerzegovina
  case bosnianCyrillic
  case bosnianCyrillicBosniaHerzegovina
  case breton
  case bretonFrance
  case bulgarian
  case bulgarianBulgaria
  case burmese
  case burmeseMyanmarBurma
  case catalan
  case catalanAndorra
  case catalanFrance
  case catalanItaly
  case catalanSpain
  case centralAtlasTamazight
  case centralAtlasTamazightMorocco
  case centralKurdish
  case centralKurdishIran
  case centralKurdishIraq
  case cherokee
  case cherokeeUnitedStates
  case chiga
  case chigaUganda
  case chinese
  case chineseChina
  case chineseHongKongSarChina
  case chineseMacauSarChina
  case chineseSimplified
  case chineseSimplifiedHongKongSarChina
  case chineseSimplifiedMacauSarChina
  case chineseSingapore
  case chineseTaiwan
  case chineseTraditional
  case colognian
  case colognianGermany
  case cornish
  case cornishUnitedKingdom
  case croatian
  case croatianBosniaHerzegovina
  case croatianCroatia
  case czech
  case czechCzechRepublic
  case danish
  case danishDenmark
  case danishGreenland
  case duala
  case dualaCameroon
  case dutch
  case dutchAruba
  case dutchBelgium
  case dutchCaribbeanNetherlands
  case dutchCuraao
  case dutchNetherlands
  case dutchSintMaarten
  case dutchSuriname
  case dzongkha
  case dzongkhaBhutan
  case embu
  case embuKenya
  case english
  case englishAlbania
  case englishAmericanSamoa
  case englishAndorra
  case englishAnguilla
  case englishAntiguaBarbuda
  case englishAustralia
  case englishAustria
  case englishBahamas
  case englishBarbados
  case englishBelgium
  case englishBelize
  case englishBermuda
  case englishBosniaHerzegovina
  case englishBotswana
  case englishBritishIndianOceanTerritory
  case englishBritishVirginIslands
  case englishCameroon
  case englishCanada
  case englishCaymanIslands
  case englishChristmasIsland
  case englishCocosKeelingIslands
  case englishCookIslands
  case englishCroatia
  case englishCyprus
  case englishCzechRepublic
  case englishDenmark
  case englishDiegoGarcia
  case englishDominica
  case englishEritrea
  case englishEstonia
  case englishEurope
  case englishFalklandIslands
  case englishFiji
  case englishFinland
  case englishFrance
  case englishGambia
  case englishGermany
  case englishGhana
  case englishGibraltar
  case englishGreece
  case englishGrenada
  case englishGuam
  case englishGuernsey
  case englishGuyana
  case englishHongKongSarChina
  case englishHungary
  case englishIceland
  case englishIndia
  case englishIreland
  case englishIsleOfMan
  case englishIsrael
  case englishItaly
  case englishJamaica
  case englishJersey
  case englishKenya
  case englishKiribati
  case englishLatvia
  case englishLesotho
  case englishLiberia
  case englishLithuania
  case englishLuxembourg
  case englishMacauSarChina
  case englishMadagascar
  case englishMalawi
  case englishMalaysia
  case englishMalta
  case englishMarshallIslands
  case englishMauritius
  case englishMicronesia
  case englishMontenegro
  case englishMontserrat
  case englishNamibia
  case englishNauru
  case englishNetherlands
  case englishNewZealand
  case englishNigeria
  case englishNiue
  case englishNorfolkIsland
  case englishNorthernMarianaIslands
  case englishNorway
  case englishPakistan
  case englishPalau
  case englishPapuaNewGuinea
  case englishPhilippines
  case englishPitcairnIslands
  case englishPoland
  case englishPortugal
  case englishPuertoRico
  case englishRomania
  case englishRussia
  case englishRwanda
  case englishSamoa
  case englishSeychelles
  case englishSierraLeone
  case englishSingapore
  case englishSintMaarten
  case englishSlovakia
  case englishSlovenia
  case englishSolomonIslands
  case englishSouthAfrica
  case englishSouthSudan
  case englishSpain
  case englishStHelena
  case englishStKittsNevis
  case englishStLucia
  case englishStVincentGrenadines
  case englishSudan
  case englishSwaziland
  case englishSweden
  case englishSwitzerland
  case englishTanzania
  case englishTokelau
  case englishTonga
  case englishTrinidadTobago
  case englishTurkey
  case englishTurksCaicosIslands
  case englishTuvalu
  case englishUSOutlyingIslands
  case englishUSVirginIslands
  case englishUganda
  case englishUnitedKingdom
  case englishUnitedStates
  case englishUnitedStatesComputer
  case englishVanuatu
  case englishWorld
  case englishZambia
  case englishZimbabwe
  case esperanto
  case estonian
  case estonianEstonia
  case ewe
  case eweGhana
  case eweTogo
  case ewondo
  case ewondoCameroon
  case faroese
  case faroeseFaroeIslands
  case filipino
  case filipinoPhilippines
  case finnish
  case finnishFinland
  case french
  case frenchAlgeria
  case frenchBelgium
  case frenchBenin
  case frenchBurkinaFaso
  case frenchBurundi
  case frenchCameroon
  case frenchCanada
  case frenchCentralAfricanRepublic
  case frenchChad
  case frenchComoros
  case frenchCongoBrazzaville
  case frenchCongoKinshasa
  case frenchCteDivoire
  case frenchDjibouti
  case frenchEquatorialGuinea
  case frenchFrance
  case frenchFrenchGuiana
  case frenchFrenchPolynesia
  case frenchGabon
  case frenchGuadeloupe
  case frenchGuinea
  case frenchHaiti
  case frenchLuxembourg
  case frenchMadagascar
  case frenchMali
  case frenchMartinique
  case frenchMauritania
  case frenchMauritius
  case frenchMayotte
  case frenchMonaco
  case frenchMorocco
  case frenchNewCaledonia
  case frenchNiger
  case frenchRunion
  case frenchRwanda
  case frenchSenegal
  case frenchSeychelles
  case frenchStBarthlemy
  case frenchStMartin
  case frenchStPierreMiquelon
  case frenchSwitzerland
  case frenchSyria
  case frenchTogo
  case frenchTunisia
  case frenchVanuatu
  case frenchWallisFutuna
  case friulian
  case friulianItaly
  case fulah
  case fulahCameroon
  case fulahGuinea
  case fulahMauritania
  case fulahSenegal
  case galician
  case galicianSpain
  case ganda
  case gandaUganda
  case georgian
  case georgianGeorgia
  case german
  case germanAustria
  case germanBelgium
  case germanGermany
  case germanLiechtenstein
  case germanLuxembourg
  case germanSwitzerland
  case greek
  case greekCyprus
  case greekGreece
  case gujarati
  case gujaratiIndia
  case gusii
  case gusiiKenya
  case hausa
  case hausaGhana
  case hausaNiger
  case hausaNigeria
  case hawaiian
  case hawaiianUnitedStates
  case hebrew
  case hebrewIsrael
  case hindi
  case hindiIndia
  case hungarian
  case hungarianHungary
  case icelandic
  case icelandicIceland
  case igbo
  case igboNigeria
  case inariSami
  case inariSamiFinland
  case indonesian
  case indonesianIndonesia
  case inuktitut
  case inuktitutUnifiedCanadianAboriginalSyllabics
  case inuktitutUnifiedCanadianAboriginalSyllabicsCanada
  case irish
  case irishIreland
  case italian
  case italianItaly
  case italianSanMarino
  case italianSwitzerland
  case japanese
  case japaneseJapan
  case jolaFonyi
  case jolaFonyiSenegal
  case kabuverdianu
  case kabuverdianuCapeVerde
  case kabyle
  case kabyleAlgeria
  case kako
  case kakoCameroon
  case kalaallisut
  case kalaallisutGreenland
  case kalenjin
  case kalenjinKenya
  case kamba
  case kambaKenya
  case kannada
  case kannadaIndia
  case kashmiri
  case kashmiriArabic
  case kashmiriArabicIndia
  case kazakh
  case kazakhKazakhstan
  case khmer
  case khmerCambodia
  case kikuyu
  case kikuyuKenya
  case kinyarwanda
  case kinyarwandaRwanda
  case konkani
  case konkaniIndia
  case korean
  case koreanNorthKorea
  case koreanSouthKorea
  case koyraChiini
  case koyraChiiniMali
  case koyraboroSenni
  case koyraboroSenniMali
  case kwasio
  case kwasioCameroon
  case kyrgyz
  case kyrgyzKyrgyzstan
  case lakota
  case lakotaUnitedStates
  case langi
  case langiTanzania
  case lao
  case laoLaos
  case latvian
  case latvianLatvia
  case lingala
  case lingalaAngola
  case lingalaCentralAfricanRepublic
  case lingalaCongoBrazzaville
  case lingalaCongoKinshasa
  case lithuanian
  case lithuanianLithuania
  case lowerSorbian
  case lowerSorbianGermany
  case lubaKatanga
  case lubaKatangaCongoKinshasa
  case luo
  case luoKenya
  case luxembourgish
  case luxembourgishLuxembourg
  case luyia
  case luyiaKenya
  case macedonian
  case macedonianMacedonia
  case machame
  case machameTanzania
  case makhuwaMeetto
  case makhuwaMeettoMozambique
  case makonde
  case makondeTanzania
  case malagasy
  case malagasyMadagascar
  case malay
  case malayArabic
  case malayArabicBrunei
  case malayArabicMalaysia
  case malayBrunei
  case malayMalaysia
  case malaySingapore
  case malayalam
  case malayalamIndia
  case maltese
  case malteseMalta
  case manx
  case manxIsleOfMan
  case marathi
  case marathiIndia
  case masai
  case masaiKenya
  case masaiTanzania
  case meru
  case meruKenya
  case meta
  case metaCameroon
  case mongolian
  case mongolianMongolia
  case morisyen
  case morisyenMauritius
  case mundang
  case mundangCameroon
  case nama
  case namaNamibia
  case nepali
  case nepaliIndia
  case nepaliNepal
  case ngiemboon
  case ngiemboonCameroon
  case ngomba
  case ngombaCameroon
  case northNdebele
  case northNdebeleZimbabwe
  case northernSami
  case northernSamiFinland
  case northernSamiNorway
  case northernSamiSweden
  case norwegianBokml
  case norwegianBokmlNorway
  case norwegianBokmlSvalbardJanMayen
  case norwegianNynorsk
  case norwegianNynorskNorway
  case nuer
  case nuerSudan
  case nyankole
  case nyankoleUganda
  case oriya
  case oriyaIndia
  case oromo
  case oromoEthiopia
  case oromoKenya
  case ossetic
  case osseticGeorgia
  case osseticRussia
  case pashto
  case pashtoAfghanistan
  case persian
  case persianAfghanistan
  case persianIran
  case polish
  case polishPoland
  case portuguese
  case portugueseAngola
  case portugueseBrazil
  case portugueseCapeVerde
  case portugueseGuineaBissau
  case portugueseMacauSarChina
  case portugueseMozambique
  case portuguesePortugal
  case portugueseSoTomPrncipe
  case portugueseTimorLeste
  case punjabi
  case punjabiArabic
  case punjabiArabicPakistan
  case punjabiIndia
  case quechua
  case quechuaBolivia
  case quechuaEcuador
  case quechuaPeru
  case romanian
  case romanianMoldova
  case romanianRomania
  case romansh
  case romanshSwitzerland
  case rombo
  case romboTanzania
  case rundi
  case rundiBurundi
  case russian
  case russianBelarus
  case russianKazakhstan
  case russianKyrgyzstan
  case russianMoldova
  case russianRussia
  case russianUkraine
  case rwa
  case rwaTanzania
  case sakha
  case sakhaRussia
  case samburu
  case samburuKenya
  case sango
  case sangoCentralAfricanRepublic
  case sangu
  case sanguTanzania
  case scottishGaelic
  case scottishGaelicUnitedKingdom
  case sena
  case senaMozambique
  case serbian
  case serbianBosniaHerzegovina
  case serbianKosovo
  case serbianLatin
  case serbianLatinBosniaHerzegovina
  case serbianLatinKosovo
  case serbianLatinMontenegro
  case serbianLatinSerbia
  case serbianMontenegro
  case serbianSerbia
  case shambala
  case shambalaTanzania
  case shona
  case shonaZimbabwe
  case sichuanYi
  case sichuanYiChina
  case sinhala
  case sinhalaSriLanka
  case slovak
  case slovakSlovakia
  case slovenian
  case slovenianSlovenia
  case soga
  case sogaUganda
  case somali
  case somaliDjibouti
  case somaliEthiopia
  case somaliKenya
  case somaliSomalia
  case spanish
  case spanishArgentina
  case spanishBolivia
  case spanishCanaryIslands
  case spanishCeutaMelilla
  case spanishChile
  case spanishColombia
  case spanishCostaRica
  case spanishCuba
  case spanishDominicanRepublic
  case spanishEcuador
  case spanishElSalvador
  case spanishEquatorialGuinea
  case spanishGuatemala
  case spanishHonduras
  case spanishLatinAmerica
  case spanishMexico
  case spanishNicaragua
  case spanishPanama
  case spanishParaguay
  case spanishPeru
  case spanishPhilippines
  case spanishPuertoRico
  case spanishSpain
  case spanishUnitedStates
  case spanishUruguay
  case spanishVenezuela
  case standardMoroccanTamazight
  case standardMoroccanTamazightMorocco
  case swahili
  case swahiliCongoKinshasa
  case swahiliKenya
  case swahiliTanzania
  case swahiliUganda
  case swedish
  case swedishlandIslands
  case swedishFinland
  case swedishSweden
  case swissGerman
  case swissGermanFrance
  case swissGermanLiechtenstein
  case swissGermanSwitzerland
  case tachelhit
  case tachelhitMorocco
  case tachelhitTifinagh
  case tachelhitTifinaghMorocco
  case taita
  case taitaKenya
  case tajik
  case tajikTajikistan
  case tamil
  case tamilIndia
  case tamilMalaysia
  case tamilSingapore
  case tamilSriLanka
  case tasawaq
  case tasawaqNiger
  case telugu
  case teluguIndia
  case teso
  case tesoKenya
  case tesoUganda
  case thai
  case thaiThailand
  case tibetan
  case tibetanChina
  case tibetanIndia
  case tigrinya
  case tigrinyaEritrea
  case tigrinyaEthiopia
  case tongan
  case tonganTonga
  case turkish
  case turkishCyprus
  case turkishTurkey
  case turkmen
  case turkmenTurkmenistan
  case ukrainian
  case ukrainianUkraine
  case upperSorbian
  case upperSorbianGermany
  case urdu
  case urduIndia
  case urduPakistan
  case uyghur
  case uyghurArabic
  case uyghurArabicChina
  case uzbek
  case uzbekArabic
  case uzbekArabicAfghanistan
  case uzbekLatin
  case uzbekLatinUzbekistan
  case uzbekUzbekistan
  case vai
  case vaiLatin
  case vaiLatinLiberia
  case vaiLiberia
  case vietnamese
  case vietnameseVietnam
  case vunjo
  case vunjoTanzania
  case walser
  case walserSwitzerland
  case welsh
  case welshUnitedKingdom
  case westernFrisian
  case westernFrisianNetherlands
  case yangben
  case yangbenCameroon
  case yiddish
  case yiddishWorld
  case yoruba
  case yorubaBenin
  case yorubaNigeria
  case zarma
  case zarmaNiger
  case zulu
  case zuluSouthAfrica
  public var locale: Foundation.Locale {
    get
  }
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public enum SuccessAction : Swift.String, Swift.Codable {
  case none
  case reload
  case backward
  case forward
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public protocol SuccessActionHandler {
  func handleSuccessAction(_ action: MobileWorkflowCore.SuccessAction)
}
extension ORKQuestionResult : MobileWorkflowCore.JSONRepresentable {
  public var jsonContent: Swift.String? {
    get
  }
}
extension ORKQuestionResult : MobileWorkflowCore.ValueProvider {
  public var content: [Swift.AnyHashable : Swift.Codable] {
    get
  }
  public func fetchProvider(for path: Swift.String) -> MobileWorkflowCore.ValueProvider?
  public func fetchValue(for path: Swift.String) -> Any?
}
public protocol SessionProvider {
}
public protocol ContentProvider : MobileWorkflowCore.JSONRepresentable {
  var preferredLanguage: Swift.String? { get }
  var fileManager: Foundation.FileManager { get }
  func jsonContent(filteredBy identifiers: [Swift.String]) -> Swift.String?
  func fetchBinaries() -> [MobileWorkflowCore.BinaryProvider]
  func resolve(value: Swift.String) -> Swift.String
  func resolve(url: Swift.String) -> Foundation.URL?
  func fetchValue(resource: Swift.String) -> Any?
}
@_hasMissingDesignatedInitializers public class Session {
  public var fileManager: Foundation.FileManager {
    get
  }
  public var valueFormatter: MobileWorkflowCore.ValueFormatter {
    get
  }
  public var urlFormatter: MobileWorkflowCore.URLFormatter {
    get
  }
  public var environment: MobileWorkflowCore.Server?
  public var preferredLanguage: Swift.String?
  public func updateSessionDependencies(fileManager: Foundation.FileManager = .default, valueFormatter: MobileWorkflowCore.ValueFormatter = ValueFormatter(), urlFormatter: MobileWorkflowCore.URLFormatter = URLFormatter())
  public func loadBinary(valueString: Swift.String) -> MobileWorkflowCore.BinaryResource?
  public func loadBinaries() -> [MobileWorkflowCore.BinaryResource]
  public func checkAndConvertBinaries(completion: @escaping ((Swift.Error?) -> Swift.Void))
  @objc deinit
}
extension Session : MobileWorkflowCore.ContentProvider {
  public func fetchValue(resource: Swift.String) -> Any?
  public func fetchBinaries() -> [MobileWorkflowCore.BinaryProvider]
  public func resolve(value: Swift.String) -> Swift.String
  public func resolve(url: Swift.String) -> Foundation.URL?
  public var jsonContent: Swift.String? {
    get
  }
  public func jsonContent(filteredBy identifiers: [Swift.String]) -> Swift.String?
}
public struct QueueControllerConfiguration : Swift.Codable {
  public let showQueueOnBadge: Swift.Bool
  public static var disabled: MobileWorkflowCore.QueueControllerConfiguration {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum Currency : Swift.String {
  case afghani, algerianDinar, argentinePeso, armenianDram, arubanFlorin, australianDollar, azerbaijanManat, bahamianDollar, bahrainiDinar, baht, balboa, barbadosDollar, belarusianRuble, belizeDollar, bermudianDollar, boliviano, bol√≠var, brazilianReal, bruneiDollar, bulgarianLev, burundiFranc, caboVerdeEscudo, canadianDollar, caymanIslandsDollar, chileanPeso, colombianPeso, comorianFranc, congoleseFranc, convertibleMark, cordobaOro, costaRicanColon, cubanPeso, czechKoruna, dalasi, danishKrone, denar, djiboutiFranc, dobra, dollar, dominicanPeso, dong, eastCaribbeanDollar, egyptianPound, elSalvadorColon, ethiopianBirr, euro, falklandIslandsPound, fijiDollar, forint, ghanaCedi, gibraltarPound, gourde, guarani, guineanFranc, guyanaDollar, hongKongDollar, hryvnia, icelandKrona, indianRupee, iranianRial, iraqiDinar, jamaicanDollar, jordanianDinar, kenyanShilling, kina, kuna, kuwaitiDinar, kwanza, kyat, laoKip, lari, lebanesePound, lek, lempira, leone, liberianDollar, libyanDinar, lilangeni, loti, malagasyAriary, malawiKwacha, malaysianRinggit, mauritiusRupee, mexicanPeso, mexicanUnidadDeInversion, moldovanLeu, moroccanDirham, mozambiqueMetical, mvdol, naira, nakfa, namibiaDollar, nepaleseRupee, netherlandsAntilleanGuilder, newIsraeliSheqel, newTaiwanDollar, newZealandDollar, ngultrum, northKoreanWon, norwegianKrone, ouguiya, paanga, pakistanRupee, pataca, pesoConvertible, pesoUruguayo, philippinePiso, poundSterling, pula, qatariRial, quetzal, rand, rialOmani, riel, romanianLeu, rufiyaa, rupiah, russianRuble, rwandaFranc, saintHelenaPound, saudiRiyal, serbianDinar, seychellesRupee, singaporeDollar, sol, solomonIslandsDollar, som, somaliShilling, somoni, southSudanesePound, sriLankaRupee, sudanesePound, surinamDollar, swedishKrona, swissFranc, syrianPound, taka, tala, tanzanianShilling, tenge, trinidadAndTobagoDollar, tugrik, tunisianDinar, turkishLira, turkmenistanNewManat, uaeDirham, ugandaShilling, unidadDeFomento, unidadDeValorReal, uruguayPesoEnUnidadesIndexadas, uzbekistanSum, vatu, wirEuro, wirFranc, won, yemeniRial, yen, yuanRenminbi, zambianKwacha, zimbabweDollar, zloty, none
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class AppConfigurationManager {
  convenience public init(dependencies: MobileWorkflowCore.AppConfigurationDependencies)
  @objc deinit
}
public protocol CredentialStoreProtocol {
  func updateCredential(_ credential: MobileWorkflowCore.Credential, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  func retrieveCredential(_ credentialType: MobileWorkflowCore.CredentialType, isRequired: Swift.Bool) -> Swift.Result<MobileWorkflowCore.Credential?, MobileWorkflowCore.CredentialError>
  func removeCredential(_ credentialType: MobileWorkflowCore.CredentialType) -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
  func wipeCredentials() -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
}
public protocol NibLoadable : AnyObject {
  static var nibName: Swift.String { get }
  static var nib: UIKit.UINib { get }
  static func nib(bundle: Foundation.Bundle?) -> UIKit.UINib
  static func loadFromNib() -> Self
  static func loadFromNib(bundle: Foundation.Bundle?) -> Self
}
extension NibLoadable {
  public static var nibName: Swift.String {
    get
  }
  public static var nib: UIKit.UINib {
    get
  }
  public static func nib(bundle: Foundation.Bundle?) -> UIKit.UINib
}
extension NibLoadable where Self : UIKit.UIView {
  public static func loadFromNib() -> Self
  public static func loadFromNib(bundle: Foundation.Bundle?) -> Self
}
extension NibLoadable where Self : UIKit.UIViewController {
  public static func loadFromNib() -> Self
  public static func loadFromNib(bundle: Foundation.Bundle?) -> Self
}
extension Dictionary where Key == Swift.String {
  public func getString(key: Swift.String) -> Swift.String?
}
extension String {
  public func fw_attributedString(baseAttributes: [Foundation.NSAttributedString.Key : Any], substringsAttributes: [(substrings: [Swift.String], attributes: [Foundation.NSAttributedString.Key : Any])] = []) -> Foundation.NSAttributedString
  public var fw_firstCapitalized: Swift.String {
    get
  }
  public func fw_camelCaseToWords() -> Swift.String
}
public protocol CurrencyFormatting {
  var maxDigitsCount: Swift.Int { get }
  var decimalDigits: Swift.Int { get set }
  var maxValue: Swift.Double? { get set }
  var minValue: Swift.Double? { get set }
  var initialText: Swift.String { get }
  var currencySymbol: Swift.String { get set }
  func string(from doubleValue: Swift.Double) -> Swift.String?
  func unformatted(string: Swift.String) -> Swift.String?
  func double(from string: Swift.String) -> Swift.Double?
}
public protocol CurrencyAdjusting {
  func formattedStringWithAdjustedDecimalSeparator(from string: Swift.String) -> Swift.String?
  func formattedStringAdjustedToFitAllowedValues(from string: Swift.String) -> Swift.String?
}
@objc public class CurrencyFormatter : ObjectiveC.NSObject, MobileWorkflowCore.CurrencyFormatting {
  public var locale: MobileWorkflowCore.LocaleConvertible {
    get
    set
  }
  @objc public var nsLocale: Foundation.NSLocale {
    @objc get
    @objc set
  }
  public var currency: MobileWorkflowCore.Currency {
    get
    set
  }
  public var showCurrencySymbol: Swift.Bool {
    get
    set
  }
  public var currencySymbol: Swift.String {
    get
    set
  }
  public var minValue: Swift.Double? {
    get
    set
  }
  public var maxValue: Swift.Double? {
    get
    set
  }
  public var decimalDigits: Swift.Int {
    get
    set
  }
  public var hasDecimals: Swift.Bool {
    get
    set
  }
  public var decimalSeparator: Swift.String {
    get
    set
  }
  @objc public var currencyCode: Swift.String {
    @objc get
    @objc set
  }
  public var alwaysShowsDecimalSeparator: Swift.Bool {
    get
    set
  }
  public var groupingSize: Swift.Int {
    get
    set
  }
  public var secondaryGroupingSize: Swift.Int {
    get
    set
  }
  public var groupingSeparator: Swift.String {
    get
    set
  }
  public var hasGroupingSeparator: Swift.Bool {
    get
    set
  }
  public var zeroSymbol: Swift.String? {
    get
    set
  }
  public var nilSymbol: Swift.String {
    get
    set
  }
  @objc final public let numberFormatter: Foundation.NumberFormatter
  public var maxIntegers: Swift.Int? {
    get
    set
  }
  public var maxDigitsCount: Swift.Int {
    get
  }
  public var initialText: Swift.String {
    get
  }
  public typealias InitHandler = ((MobileWorkflowCore.CurrencyFormatter) -> (Swift.Void))
  @objc public init(_ handler: MobileWorkflowCore.CurrencyFormatter.InitHandler? = nil)
  @objc deinit
  @objc override dynamic public init()
}
extension CurrencyFormatter {
  @objc dynamic public func string(from doubleValue: Swift.Double) -> Swift.String?
  public func double(from string: Swift.String) -> Swift.Double?
  @objc dynamic public func doubleAsNSNumber(from string: Swift.String) -> Foundation.NSNumber?
  @objc dynamic public func unformatted(string: Swift.String) -> Swift.String?
}
extension CurrencyFormatter : MobileWorkflowCore.CurrencyAdjusting {
  public func formattedStringWithAdjustedDecimalSeparator(from string: Swift.String) -> Swift.String?
  public func formattedStringAdjustedToFitAllowedValues(from string: Swift.String) -> Swift.String?
}
extension ORKChoiceQuestionResult : MobileWorkflowCore.NavigationTriggerResult {
  public var navigationDestinationKey: Swift.String? {
    get
  }
}
public enum BinaryContentType {
  public enum Image {
    public static let heif: Swift.String
    public static let jpeg: Swift.String
  }
  public enum Video {
    public static let mp4: Swift.String
  }
  public enum Application {
    public static let pdf: Swift.String
  }
}
extension ORKFileResult : MobileWorkflowCore.BinaryProvider {
  public var binaryIdentifier: Swift.String {
    get
  }
  public var cachePath: Swift.String? {
    get
  }
  public var fileName: Swift.String? {
    get
  }
  public var fileType: Swift.String? {
    get
  }
  public func load(using fileManager: Foundation.FileManager) -> Foundation.Data?
}
public class LocationUploadService {
  public init?(config: MobileWorkflowCore.LocationUploadServiceConfiguration, session: MobileWorkflowCore.Session, networkService: MobileWorkflowCore.AsyncTaskService, credentialStore: MobileWorkflowCore.CredentialStoreProtocol, eventService: MobileWorkflowCore.EventService)
  @objc deinit
}
extension CLLocation : Swift.Encodable {
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case latitude
    case longitude
    case timestamp
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
    public init?(stringValue: Swift.String)
    public var intValue: Swift.Int? {
      get
    }
    public init?(intValue: Swift.Int)
  }
  public func encode(to encoder: Swift.Encoder) throws
}
final public class CredentialStore : MobileWorkflowCore.CredentialStoreProtocol {
  public init(securityStore: MobileWorkflowCore.SecurityStoreProtocol = SecurityStore())
  final public func updateCredential(_ credential: MobileWorkflowCore.Credential, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  final public func saveCredential(_ credential: MobileWorkflowCore.Credential, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  final public func removeCredential(_ credentialType: MobileWorkflowCore.CredentialType) -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
  final public func retrieveCredential(_ credentialType: MobileWorkflowCore.CredentialType, isRequired: Swift.Bool) -> Swift.Result<MobileWorkflowCore.Credential?, MobileWorkflowCore.CredentialError>
  final public func wipeCredentials() -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
  @objc deinit
}
public struct NetworkDisplayItemTask : MobileWorkflowCore.CredentializedAsyncTask, MobileWorkflowCore.URLAsyncTaskConvertible {
  public typealias Response = [MobileWorkflowCore.DisplayItem]
  public let input: Foundation.URL
  public let credential: MobileWorkflowCore.Credential?
  public typealias Input = Foundation.URL
}
public struct ValueFormatter {
  public static let DefaultValueComposerRegex: Swift.String
  public init(regex: Swift.String = DefaultValueComposerRegex)
  public func parseIdentifier(valueString: Swift.String, using session: MobileWorkflowCore.ContentProvider?) -> Swift.String?
  public func parse(valueString: Swift.String, using session: MobileWorkflowCore.ContentProvider?) -> Swift.String?
}
public protocol ReusableView : AnyObject {
  static var defaultReuseIdentifier: Swift.String { get }
}
extension ReusableView where Self : UIKit.UIView {
  public static var defaultReuseIdentifier: Swift.String {
    get
  }
}
extension UICollectionViewCell : MobileWorkflowCore.ReusableView {
}
extension UICollectionView {
  public func register<T>(_: T.Type) where T : UIKit.UICollectionViewCell
  public func register<T>(_: T.Type) where T : UIKit.UICollectionViewCell, T : MobileWorkflowCore.NibLoadable
  public func dequeueReusableCell<T>(forIndexPath indexPath: Foundation.IndexPath) -> T where T : UIKit.UICollectionViewCell
  public func register<T>(_: T.Type, forSupplementaryViewOfKind elementKind: Swift.String) where T : UIKit.UICollectionReusableView, T : MobileWorkflowCore.ReusableView
  public func register<T>(_: T.Type, forSupplementaryViewOfKind elementKind: Swift.String) where T : UIKit.UICollectionReusableView, T : MobileWorkflowCore.NibLoadable, T : MobileWorkflowCore.ReusableView
  public func dequeueReusableSupplementaryViewOfKind<T>(_ elementKind: Swift.String, forIndexPath indexPath: Foundation.IndexPath) -> T where T : UIKit.UICollectionReusableView, T : MobileWorkflowCore.ReusableView
}
extension UITableViewCell : MobileWorkflowCore.ReusableView {
}
extension UITableView {
  public func register<T>(_: T.Type) where T : UIKit.UITableViewCell
  public func register<T>(_: T.Type) where T : UIKit.UITableViewCell, T : MobileWorkflowCore.NibLoadable
  public func dequeueReusableCell<T>(forIndexPath indexPath: Foundation.IndexPath) -> T where T : UIKit.UITableViewCell
}
extension UITableViewHeaderFooterView : MobileWorkflowCore.ReusableView {
}
extension UITableView {
  public func register<T>(_: T.Type) where T : UIKit.UITableViewHeaderFooterView, T : MobileWorkflowCore.NibLoadable
  public func dequeueHeaderFooterView<T>() -> T where T : UIKit.UITableViewHeaderFooterView
}
public protocol ImageLoadingService {
  func syncLoad(image: Swift.String, session: MobileWorkflowCore.Session) -> UIKit.UIImage?
  func asyncLoad(image: Swift.String, session: MobileWorkflowCore.Session, completion: ((UIKit.UIImage?) -> Swift.Void)?) -> Combine.AnyCancellable?
}
extension ImageLoadingService {
  public func syncLoad(image: Swift.String, session: MobileWorkflowCore.Session) -> UIKit.UIImage?
  public func asyncLoad(image: Swift.String, session: MobileWorkflowCore.Session, completion: ((UIKit.UIImage?) -> Swift.Void)?) -> Combine.AnyCancellable?
}
public protocol MobileWorkflowImageTableViewCellDelegate : AnyObject {
  func imageCell(_ cell: MobileWorkflowCore.MobileWorkflowImageTableViewCell, didTapButton button: UIKit.UIButton)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class MobileWorkflowImageTableViewCell : UIKit.UITableViewCell {
  public var delegate: MobileWorkflowCore.MobileWorkflowImageTableViewCellDelegate?
  public var backgroundImage: UIKit.UIImage? {
    get
    set
  }
  public func configure()
  public func setContentMode(_ contentMode: UIKit.UIView.ContentMode)
  @objc deinit
}
@objc public class DisplayItem : ObjectiveC.NSObject, Swift.Codable, Foundation.NSCopying, Foundation.NSCoding, Foundation.NSSecureCoding {
  @objc public static var supportsSecureCoding: Swift.Bool {
    @objc get
  }
  public enum ItemType : Swift.String, Swift.Codable {
    case text
    case image
    case video
    case button
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  final public let type: MobileWorkflowCore.DisplayItem.ItemType
  public var name: Swift.String?
  final public let label: Swift.String?
  final public let text: Swift.String?
  final public let previewURL: Swift.String?
  final public let url: Swift.String?
  final public let method: Swift.String?
  final public let onSuccess: MobileWorkflowCore.SuccessAction?
  final public let modalWorkflow: Swift.String?
  final public let buttonStyle: MobileWorkflowCore.DisplayItemButtonStyle?
  final public let contentMode: MobileWorkflowCore.ContentMode?
  final public let systemURL: Swift.String?
  @objc required convenience public init?(coder: Foundation.NSCoder)
  public init(type: MobileWorkflowCore.DisplayItem.ItemType, name: Swift.String?, label: Swift.String?, text: Swift.String?, previewURL: Swift.String?, url: Swift.String?, method: Swift.String?, onSuccess: MobileWorkflowCore.SuccessAction?, modalWorkflow: Swift.String?, buttonStyle: MobileWorkflowCore.DisplayItemButtonStyle?, contentMode: MobileWorkflowCore.ContentMode?, systemURL: Swift.String? = nil) throws
  @objc public func encode(with coder: Foundation.NSCoder)
  @objc public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public typealias DisplayItemButtonStyle = MobileWorkflowCore.ButtonStyle
public enum ContentMode : Swift.String, Swift.Codable {
  case scaleAspectFit
  case scaleAspectFill
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public typealias SystemAction = Swift.String
extension UITextField {
  public var selectedTextRangeOffsetFromEnd: Swift.Int {
    get
  }
  public func setInitialSelectedTextRange()
  public func updateSelectedTextRange(lastOffsetFromEnd: Swift.Int)
}
public struct BinaryResource : Swift.Codable {
  public let idenfifer: Swift.String
  public let fileType: Swift.String?
  public let data: Foundation.Data
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol URLAsyncTaskConvertible {
  func convertToURLAsyncTask<T>(using session: MobileWorkflowCore.ContentProvider) -> T? where T : MobileWorkflowCore.AsyncTask
}
extension URLAsyncTaskConvertible where Self : MobileWorkflowCore.CredentializedAsyncTask, Self.Input == Foundation.URL, Self.Response : Swift.Decodable {
  public func convertToURLAsyncTask<T>(using session: MobileWorkflowCore.ContentProvider) -> T? where T : MobileWorkflowCore.AsyncTask
}
public struct ResultsUploadTask : Swift.Codable, MobileWorkflowCore.QueueableTask, MobileWorkflowCore.CredentializedAsyncTask {
  public let type: Swift.String
  public typealias Response = Foundation.Data
  public typealias UrlString = Swift.String
  public typealias Input = MobileWorkflowCore.ResultsUploadTask.UrlString
  public let input: MobileWorkflowCore.ResultsUploadTask.UrlString
  public let requestPropertyIdentifiers: [Swift.String]
  public let credential: MobileWorkflowCore.Credential?
  public let queueNetworkUploads: Swift.Bool
  public func encode(encoder: Foundation.JSONEncoder) throws -> Foundation.Data
  public static func decode(decoder: Foundation.JSONDecoder, data: Foundation.Data) throws -> MobileWorkflowCore.ResultsUploadTask
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum Event {
  case notification(name: Foundation.NSNotification.Name)
  case apnsTokenRegistered
  case significantLocationChanges
  case applicationOpensURL
}
public protocol EventService : MobileWorkflowCore.AppEventDelegate, MobileWorkflowCore.AuthRedirector, MobileWorkflowCore.SceneEventDelegate {
  func publisher<T>(for event: MobileWorkflowCore.Event) -> Combine.AnyPublisher<T?, Swift.Error>
}
public class EventServiceImplementation : MobileWorkflowCore.EventService {
  public var authFlowResumer: MobileWorkflowCore.AuthFlowResumer?
  public init(notificationCenter: Foundation.NotificationCenter = .default, apnsRegister: MobileWorkflowCore.APNSRegister = UIApplication.shared)
  public func publisher<T>(for event: MobileWorkflowCore.Event) -> Combine.AnyPublisher<T?, Swift.Error>
  @objc deinit
}
public protocol APNSRegister {
  func registerForRemoteNotifications()
}
extension UIApplication : MobileWorkflowCore.APNSRegister {
}
public protocol AppEventDelegator : AnyObject {
  var eventDelegate: MobileWorkflowCore.AppEventDelegate? { get set }
}
public protocol QueueControllerProvider : AnyObject {
  var queueController: MobileWorkflowCore.QueueControllerNetworkAsyncTaskService! { get }
}
public protocol AppEventDelegate : AnyObject {
  func application(_ app: UIKit.UIApplication, open url: Foundation.URL, options: [UIKit.UIApplication.OpenURLOptionsKey : Any]) -> Swift.Bool
  func application(_ application: UIKit.UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Foundation.Data)
  func application(_ application: UIKit.UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Swift.Error)
}
public protocol SceneEventDelegate : AnyObject {
  func scene(_ scene: UIKit.UIScene, openURLContexts URLContexts: Swift.Set<UIKit.UIOpenURLContext>)
}
extension EventServiceImplementation {
  public func application(_ app: UIKit.UIApplication, open url: Foundation.URL, options: [UIKit.UIApplication.OpenURLOptionsKey : Any]) -> Swift.Bool
  public func application(_ application: UIKit.UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Foundation.Data)
  public func application(_ application: UIKit.UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Swift.Error)
}
extension EventServiceImplementation {
  public func scene(_ scene: UIKit.UIScene, openURLContexts URLContexts: Swift.Set<UIKit.UIOpenURLContext>)
}
@objc @_hasMissingDesignatedInitializers public class MobileWorkflowRootViewController : UIKit.UIViewController {
  public init(manager: MobileWorkflowCore.AppConfigurationManager, preferredConfigurations: [MobileWorkflowCore.AppConfigurationContext] = [], userDefaults: Foundation.UserDefaults = .standard)
  @objc override dynamic public func viewDidLoad()
  public func loadAppConfiguration(_ context: MobileWorkflowCore.AppConfigurationContext)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
@objc public class ListStepItem : ObjectiveC.NSObject, Swift.Codable, Foundation.NSCopying, Foundation.NSCoding, Foundation.NSSecureCoding {
  @objc public static var supportsSecureCoding: Swift.Bool {
    @objc get
  }
  final public let id: Swift.String
  final public let text: Swift.String
  final public let detailText: Swift.String?
  final public let sfSymbolName: Swift.String?
  final public let imageURL: Swift.String?
  @objc required convenience public init?(coder: Foundation.NSCoder)
  required public init(from decoder: Swift.Decoder) throws
  public init(id: Swift.String, text: Swift.String, detailText: Swift.String?, sfSymbolName: Swift.String?, imageURL: Swift.String?)
  @objc public func encode(with coder: Foundation.NSCoder)
  @objc public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  @objc override dynamic public init()
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
extension ListStepItem {
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
}
extension ListStepItem : MobileWorkflowCore.ValueProvider {
  public func fetchValue(for path: Swift.String) -> Any?
  public func fetchProvider(for path: Swift.String) -> MobileWorkflowCore.ValueProvider?
  public var content: [Swift.AnyHashable : Swift.Codable] {
    get
  }
}
public struct NetworkListItemTask : MobileWorkflowCore.CredentializedAsyncTask, MobileWorkflowCore.URLAsyncTaskConvertible {
  public typealias Response = [MobileWorkflowCore.ListStepItem]
  public let input: Foundation.URL
  public let credential: MobileWorkflowCore.Credential?
  public typealias Input = Foundation.URL
}
public protocol CurrencyString {
  var representsZero: Swift.Bool { get }
  var hasNumbers: Swift.Bool { get }
  var lastNumberOffsetFromEnd: Swift.Int? { get }
  func numeralFormat() -> Swift.String
  mutating func updateDecimalSeparator(decimalDigits: Swift.Int)
}
extension String : MobileWorkflowCore.CurrencyString {
  public var representsZero: Swift.Bool {
    get
  }
  public var hasNumbers: Swift.Bool {
    get
  }
  public var lastNumberOffsetFromEnd: Swift.Int? {
    get
  }
  public mutating func updateDecimalSeparator(decimalDigits: Swift.Int)
  public func numeralFormat() -> Swift.String
}
extension String {
  public static let negativeSymbol: Swift.String
}
public struct URLTaskInput {
  public let url: Foundation.URL
  public let method: MobileWorkflowCore.HTTPMethod
  public let body: Foundation.Data?
  public let headers: [Swift.String : Swift.String]
  public init(url: Foundation.URL, method: MobileWorkflowCore.HTTPMethod, body: Foundation.Data? = nil, headers: [Swift.String : Swift.String] = [:])
}
public struct URLAsyncTask<T> : MobileWorkflowCore.AsyncTask {
  public typealias Response = T
  public typealias URLTaskParser = (Foundation.Data) throws -> T
  public let input: MobileWorkflowCore.URLTaskInput
  public let parser: MobileWorkflowCore.URLAsyncTask<T>.URLTaskParser
  public typealias Input = MobileWorkflowCore.URLTaskInput
}
extension URLAsyncTask {
  public static func build<T>(url: Foundation.URL, method: MobileWorkflowCore.HTTPMethod, body: Foundation.Data? = nil, session: MobileWorkflowCore.ContentProvider, credential: MobileWorkflowCore.Credential? = nil, headers: [Swift.String : Swift.String] = [:], parser: @escaping (Foundation.Data) throws -> T) -> MobileWorkflowCore.URLAsyncTask<T>
}
extension URLAsyncTask where T == Foundation.Data {
  public static func build(urlString: Swift.String, requestPropertyIdentifiers: [Swift.String], session: MobileWorkflowCore.ContentProvider, accept: Swift.String = "application/json", credential: MobileWorkflowCore.Credential?, fileManager: Foundation.FileManager) throws -> MobileWorkflowCore.URLAsyncTask<MobileWorkflowCore.URLAsyncTask<T>.Response>
}
public protocol NavigationTriggerResult {
  var navigationDestinationKey: Swift.String? { get }
}
public typealias Parse<T> = (Foundation.Data) throws -> T
public typealias ParsePublisher<T> = (Combine.AnyPublisher<Foundation.Data, Swift.Error>) -> Combine.AnyPublisher<T, Swift.Error>
extension Decodable {
  public static func parse(data: Foundation.Data, decoder: Foundation.JSONDecoder = JSONDecoder()) throws -> Self
  public static func decodeParse(decoder: Foundation.JSONDecoder = JSONDecoder()) -> MobileWorkflowCore.Parse<Self>
  public static func parsePublisher(_ parse: @escaping MobileWorkflowCore.Parse<Self> = Self.decodeParse()) -> MobileWorkflowCore.ParsePublisher<Self>
}
public struct ServiceConfiguration : Swift.Codable {
  public let type: Swift.String
  public let properties: [Swift.String : Any]
  public init(from decoder: Swift.Decoder) throws
  public init(type: Swift.String, properties: [Swift.String : Any])
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol RemoteContentStepViewController : UIKit.UIViewController, MobileWorkflowCore.WorkflowPresentationDelegator {
  associatedtype StepType : MobileWorkflowCore.RemoteContentStep
  var remoteContentStep: Self.StepType! { get }
  var showBadURLError: Swift.Bool { get }
  func loadContent()
  func showLoading()
  func hideLoading()
  func update(content: Self.StepType.ResponseType)
}
extension RemoteContentStepViewController {
  public var showBadURLError: Swift.Bool {
    get
  }
}
extension RemoteContentStepViewController where Self.StepType.ResponseType : Swift.Decodable {
  public func loadContent()
}
extension UIFont {
  public static func preferredFont(forTextStyle style: UIKit.UIFont.TextStyle, weight: UIKit.UIFont.Weight) -> UIKit.UIFont
}
public class NetworkAsyncTaskService : MobileWorkflowCore.AsyncTaskService {
  public init(urlSession: Foundation.URLSession = .shared)
  public func canPerform<T>(task: T) -> Swift.Bool where T : MobileWorkflowCore.AsyncTask
  public func perform<T>(task: T, session: MobileWorkflowCore.ContentProvider, respondOn: Dispatch.DispatchQueue, completion: @escaping (Swift.Result<T.Response, Swift.Error>) -> Swift.Void) where T : MobileWorkflowCore.AsyncTask
  @objc deinit
}
extension ORKPredicateStepNavigationRule {
  convenience public init(resultPredicatesAndDestinationStepIdentifiers tuples: [(resultPredicate: Foundation.NSPredicate, destinationStepIdentifier: Swift.String)], defaultStepIdentifierOrNil: Swift.String? = nil)
}
public protocol AsyncTaskService {
  @discardableResult
  func canPerform<T>(task: T) -> Swift.Bool where T : MobileWorkflowCore.AsyncTask
  func perform<T>(task: T, session: MobileWorkflowCore.ContentProvider, respondOn: Dispatch.DispatchQueue, completion: @escaping (Swift.Result<T.Response, Swift.Error>) -> Swift.Void) where T : MobileWorkflowCore.AsyncTask
  func perform<T>(task: T, session: MobileWorkflowCore.ContentProvider, completion: @escaping (Swift.Result<T.Response, Swift.Error>) -> Swift.Void) where T : MobileWorkflowCore.AsyncTask
}
extension AsyncTaskService {
  public func perform<T>(task: T, session: MobileWorkflowCore.ContentProvider, completion: @escaping (Swift.Result<T.Response, Swift.Error>) -> Swift.Void) where T : MobileWorkflowCore.AsyncTask
}
extension AsyncTaskService {
  public func notify<T>(result: Swift.Result<T, Swift.Error>, on: Dispatch.DispatchQueue, completion: @escaping (Swift.Result<T, Swift.Error>) -> Swift.Void)
}
public enum HTTPMethod : Swift.String {
  case GET
  case HEAD
  case POST
  case PUT
  case DELETE
  case CONNECT
  case OPTIONS
  case TRACE
  case PATCH
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
}
extension QueueControllerNetworkAsyncTaskService : Foundation.URLSessionTaskDelegate {
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic public func urlSessionDidFinishEvents(forBackgroundURLSession session: Foundation.URLSession)
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willBeginDelayedRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLSession.DelayedRequestDisposition, Foundation.URLRequest?) -> Swift.Void)
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, needNewBodyStream completionHandler: @escaping (Foundation.InputStream?) -> Swift.Void)
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
}
@objc @_inheritsConvenienceInitializers public class CurrencyUITextFieldDelegate : ObjectiveC.NSObject {
  public var formatter: (MobileWorkflowCore.CurrencyAdjusting & MobileWorkflowCore.CurrencyFormatting)!
  public var clearsWhenValueIsZero: Swift.Bool
  @objc public var passthroughDelegate: UIKit.UITextFieldDelegate? {
    @objc get
    @objc set
  }
  @objc override dynamic public init()
  @objc public init(formatter: MobileWorkflowCore.CurrencyFormatter)
  @objc deinit
}
extension CurrencyUITextFieldDelegate : UIKit.UITextFieldDelegate {
  @discardableResult
  @objc dynamic open func textFieldShouldBeginEditing(_ textField: UIKit.UITextField) -> Swift.Bool
  @objc dynamic public func textFieldDidBeginEditing(_ textField: UIKit.UITextField)
  @discardableResult
  @objc dynamic public func textFieldShouldEndEditing(_ textField: UIKit.UITextField) -> Swift.Bool
  @objc dynamic open func textFieldDidEndEditing(_ textField: UIKit.UITextField)
  @discardableResult
  @objc dynamic open func textFieldShouldClear(_ textField: UIKit.UITextField) -> Swift.Bool
  @discardableResult
  @objc dynamic open func textFieldShouldReturn(_ textField: UIKit.UITextField) -> Swift.Bool
  @discardableResult
  @objc dynamic public func textField(_ textField: UIKit.UITextField, shouldChangeCharactersIn range: Foundation.NSRange, replacementString string: Swift.String) -> Swift.Bool
}
public protocol NamedType {
  var typeName: Swift.String { get }
}
public protocol MobileWorkflowStepType : MobileWorkflowCore.NamedType {
  var stepClass: MobileWorkflowCore.MobileWorkflowStep.Type { get }
}
public protocol MobileWorkflowServiceType : MobileWorkflowCore.NamedType {
  func buildService(with config: MobileWorkflowCore.ServiceConfiguration) throws -> MobileWorkflowCore.AsyncTaskService?
}
public protocol MobileWorkflowPlugin {
  static var allStepsTypes: [MobileWorkflowCore.MobileWorkflowStepType] { get }
  static var networkServiceType: MobileWorkflowCore.MobileWorkflowServiceType { get }
}
extension MobileWorkflowPlugin {
  public static var allStepsTypes: [MobileWorkflowCore.MobileWorkflowStepType] {
    get
  }
  public static var networkServiceType: MobileWorkflowCore.MobileWorkflowServiceType {
    get
  }
}
public protocol MobileWorkflowStep : MobileWorkflowCore.BuildableStep {
}
extension MobileWorkflowServiceType {
  public func buildDecodableService<T>(type: T.Type, with config: MobileWorkflowCore.ServiceConfiguration) throws -> T where T : MobileWorkflowCore.AsyncTaskService, T : Swift.Decodable
}
public struct StepContext {
  public let appName: Swift.String?
  public let workflowName: Swift.String?
  public let systemTintColor: UIKit.UIColor
  public let authenticationWorkflowId: Swift.String?
}
public struct StepInfo {
  public let data: MobileWorkflowCore.StepData
  public let context: MobileWorkflowCore.StepContext
  public let session: MobileWorkflowCore.Session
}
public struct StepData : Swift.Codable {
  public let type: Swift.String
  public let identifier: Swift.String
  public let uuid: Swift.String
  public let image: UIKit.UIImage?
  public let imageURL: Swift.String?
  public let content: [Swift.String : Any]
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class StateView : UIKit.UIView {
  public struct ButtonConfig {
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc override dynamic public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  public func configure(isLoading: Swift.Bool = false, title: Swift.String? = nil, subtitle: Swift.String? = nil, buttonConfig: MobileWorkflowCore.StateView.ButtonConfig? = nil)
  @objc deinit
}
extension URLRequest {
  public func curlString() -> Swift.String
}
extension ORKSignatureResult : MobileWorkflowCore.BinaryProvider {
  public var fileURL: Foundation.URL? {
    get
  }
  public var binaryIdentifier: Swift.String {
    get
  }
  public var cachePath: Swift.String? {
    get
  }
  public var contentType: Swift.String? {
    get
  }
  public var fileName: Swift.String? {
    get
  }
  public var fileType: Swift.String? {
    get
  }
  public func load(using fileManager: Foundation.FileManager) -> Foundation.Data?
}
extension UIColor {
  public func adjustedColorForBestContrast(withColor otherColor: UIKit.UIColor) -> UIKit.UIColor
}
extension ORKImageCaptureStep : MobileWorkflowCore.MobileWorkflowStep {
  public static func build(step: MobileWorkflowCore.StepInfo, services: MobileWorkflowCore.MobileWorkflowServices) throws -> MobileWorkflowCore.ORKStep
}
public enum AppConfigurationContext {
  case remote(url: Swift.String, serverId: Swift.Int?)
  case cached
  case file(path: Swift.String, serverId: Swift.Int?, workflowId: Swift.String?, sessionValues: [Swift.String : Any]? = nil)
}
extension Collection where Self.Element == MobileWorkflowCore.URLSchemeManager {
  public func firstValidConfiguration(from urlContexts: Swift.Set<UIKit.UIOpenURLContext>) -> MobileWorkflowCore.AppConfigurationContext?
}
public protocol HasSecondaryWorkflows : AnyObject {
  var secondaryWorkflowIDs: [Swift.String] { get }
}
public struct LocalizationService {
  public func translate(_ stringToTranslate: Swift.String?) -> Swift.String?
}
public struct NetworkStepBinaryResponse : Swift.Codable {
  public let identifier: Swift.String
  public let url: Swift.String
  public let method: Swift.String
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum CredentialError : Swift.Error {
  case invalidInputData
  case storingError
  case requiredButNotFound
  case unexpected
  public static func == (a: MobileWorkflowCore.CredentialError, b: MobileWorkflowCore.CredentialError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class MobileWorkflowSubtitleTableViewCell : UIKit.UITableViewCell {
  public struct ViewData {
  }
  public var viewData: MobileWorkflowCore.MobileWorkflowSubtitleTableViewCell.ViewData? {
    get
    set
  }
  @objc override dynamic public func layoutSubviews()
  public func updateImage(_ image: UIKit.UIImage?)
  public func configureStyle(titleFont: UIKit.UIFont = .preferredFont(forTextStyle: .headline, weight: .regular), titleTextColor: UIKit.UIColor = .label, subtitleFont: UIKit.UIFont = .preferredFont(forTextStyle: .subheadline, weight: .regular), subtitleTextColor: UIKit.UIColor = .secondaryLabel)
  @objc deinit
}
public struct Server : Swift.Codable {
  public let id: Swift.Int
  public let url: Foundation.URL
  public init(id: Swift.Int, url: Foundation.URL)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum Attachment {
  case filePath(_: Swift.String)
  case data(_: Foundation.Data, mimeType: Swift.String, fileName: Swift.String)
}
@objc @_inheritsConvenienceInitializers open class MobileWorkflowEmailViewController : MobileWorkflowCore.MobileWorkflowButtonViewController {
  public var emailStep: (MobileWorkflowCore.ORKStep & MobileWorkflowCore.EmailStep)! {
    get
  }
  @objc override dynamic public func viewDidLoad()
  open func extractAttachements(completion: @escaping (Swift.Result<[MobileWorkflowCore.Attachment], Swift.Error>) -> Swift.Void)
  public func extractAnswerContent() -> Swift.String?
  open func openEmailComposer(sendTo: Swift.String, subject: Swift.String, body: Swift.String?, attachments: [MobileWorkflowCore.Attachment])
  @objc deinit
  @objc override dynamic public init(step: MobileWorkflowCore.ORKStep?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension MobileWorkflowEmailViewController : MessageUI.MFMailComposeViewControllerDelegate {
  @objc dynamic public func mailComposeController(_ controller: MessageUI.MFMailComposeViewController, didFinishWith result: MessageUI.MFMailComposeResult, error: Swift.Error?)
}
public protocol ValueProvider : MobileWorkflowCore.SessionProvider {
  var content: [Swift.AnyHashable : Swift.Codable] { get }
  func fetchValue(for path: Swift.String) -> Any?
  func fetchProvider(for path: Swift.String) -> MobileWorkflowCore.ValueProvider?
}
extension String : MobileWorkflowCore.ValueProvider {
  public var content: [Swift.AnyHashable : Swift.Codable] {
    get
  }
  public func fetchValue(for path: Swift.String) -> Any?
  public func fetchProvider(for path: Swift.String) -> MobileWorkflowCore.ValueProvider?
}
extension Dictionary : MobileWorkflowCore.SessionProvider {
}
extension Dictionary : MobileWorkflowCore.ValueProvider where Key == Swift.String {
  public var content: [Swift.AnyHashable : Swift.Codable] {
    get
  }
  public func fetchValue(for path: Swift.String) -> Any?
  public func fetchProvider(for path: Swift.String) -> MobileWorkflowCore.ValueProvider?
}
public enum SyncResult {
  case alreadyInSync
  case didSync
  public static func == (a: MobileWorkflowCore.SyncResult, b: MobileWorkflowCore.SyncResult) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol SyncableContentSource : AnyObject {
  var resolvedURL: Foundation.URL? { get set }
  func syncContentSource() -> MobileWorkflowCore.SyncResult
}
extension SyncableContentSource where Self : MobileWorkflowCore.RemoteContentStep {
  public func syncContentSource() -> MobileWorkflowCore.SyncResult
}
public protocol ContentClearable {
  func clearContent()
}
extension RemoteContentStepViewController where Self : MobileWorkflowCore.ContentClearable, Self.StepType : MobileWorkflowCore.SyncableContentSource {
  public func resyncContent()
}
public enum ViewOrder {
  case top
  case above(view: UIKit.UIView)
  case below(view: UIKit.UIView)
}
extension UIView {
  public func addPinnedSubview(_ view: UIKit.UIView, order: MobileWorkflowCore.ViewOrder = .top, horizontalLayoutGuide: UIKit.UILayoutGuide? = nil, verticalLayoutGuide: UIKit.UILayoutGuide? = nil, insets: UIKit.NSDirectionalEdgeInsets = .zero)
}
public enum WorkflowFinishReason : Swift.Equatable {
  case discarded
  case completed
  case failed(error: Swift.Error?)
  public static func == (lhs: MobileWorkflowCore.WorkflowFinishReason, rhs: MobileWorkflowCore.WorkflowFinishReason) -> Swift.Bool
}
public enum ButtonStyle : Swift.String, Swift.Codable {
  case primary
  case danger
  case outline
  case textOnly
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
extension NumberFormatter {
  public func string(from doubleValue: Swift.Double?) -> Swift.String?
}
public struct AuthRedirectHandler {
  public init(_ handler: @escaping (MobileWorkflowCore.AuthFlowResumer) -> Swift.Void)
}
public protocol AuthProvider {
  func authenticate(completion: @escaping (Swift.Result<MobileWorkflowCore.Credential, Swift.Error>) -> Swift.Void) -> MobileWorkflowCore.AuthFlowResumer
}
public class AuthProviderImplementation : MobileWorkflowCore.AuthProvider {
  public init(_ start: @escaping (@escaping (Swift.Result<MobileWorkflowCore.Credential, Swift.Error>) -> Swift.Void) -> MobileWorkflowCore.AuthFlowResumer)
  public func authenticate(completion: @escaping (Swift.Result<MobileWorkflowCore.Credential, Swift.Error>) -> Swift.Void) -> MobileWorkflowCore.AuthFlowResumer
  @objc deinit
}
public protocol AuthFlowResumer : AnyObject {
  func resumeAuth(with url: Foundation.URL) -> Swift.Bool
}
public protocol AuthRedirector : AnyObject {
  var authFlowResumer: MobileWorkflowCore.AuthFlowResumer? { get set }
}
extension AuthRedirector {
  public func authRedirectHandler() -> MobileWorkflowCore.AuthRedirectHandler
  public func handleAuthRedirect(for url: Foundation.URL) -> Swift.Bool
}
public enum ReachabilityStatus : Swift.String {
  case offline
  case online
  case unknown
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public class Reachability {
  public static let kReachabilityStatusNotificationName: Foundation.NSNotification.Name
  public static let kStatusUserInfo: Swift.String
  public static let kDomainUserInfo: Swift.String
  public init(host: Swift.String = "google.com")
  @objc deinit
}
extension ReachabilityStatus {
  public init(reachabilityFlags flags: SystemConfiguration.SCNetworkReachabilityFlags)
}
extension MobileWorkflowCore.LocationServiceError : Swift.Equatable {}
extension MobileWorkflowCore.LocationServiceError : Swift.Hashable {}
extension MobileWorkflowCore.QueueControllerNetworkAsyncTaskService.Exceptions : Swift.Equatable {}
extension MobileWorkflowCore.QueueControllerNetworkAsyncTaskService.Exceptions : Swift.Hashable {}
extension MobileWorkflowCore.CredentialType : Swift.Equatable {}
extension MobileWorkflowCore.CredentialType : Swift.Hashable {}
extension MobileWorkflowCore.CredentialType : Swift.RawRepresentable {}
extension MobileWorkflowCore.CurrencyLocale : Swift.Equatable {}
extension MobileWorkflowCore.CurrencyLocale : Swift.Hashable {}
extension MobileWorkflowCore.CurrencyLocale : Swift.RawRepresentable {}
extension MobileWorkflowCore.SuccessAction : Swift.Equatable {}
extension MobileWorkflowCore.SuccessAction : Swift.Hashable {}
extension MobileWorkflowCore.SuccessAction : Swift.RawRepresentable {}
extension MobileWorkflowCore.Currency : Swift.Equatable {}
extension MobileWorkflowCore.Currency : Swift.Hashable {}
extension MobileWorkflowCore.Currency : Swift.RawRepresentable {}
extension CoreLocation.CLLocation.CodingKeys : Swift.Equatable {}
extension CoreLocation.CLLocation.CodingKeys : Swift.Hashable {}
extension CoreLocation.CLLocation.CodingKeys : Swift.RawRepresentable {}
extension MobileWorkflowCore.DisplayItem.ItemType : Swift.Equatable {}
extension MobileWorkflowCore.DisplayItem.ItemType : Swift.Hashable {}
extension MobileWorkflowCore.DisplayItem.ItemType : Swift.RawRepresentable {}
extension MobileWorkflowCore.ContentMode : Swift.Equatable {}
extension MobileWorkflowCore.ContentMode : Swift.Hashable {}
extension MobileWorkflowCore.ContentMode : Swift.RawRepresentable {}
extension MobileWorkflowCore.HTTPMethod : Swift.Equatable {}
extension MobileWorkflowCore.HTTPMethod : Swift.Hashable {}
extension MobileWorkflowCore.HTTPMethod : Swift.RawRepresentable {}
extension MobileWorkflowCore.CredentialError : Swift.Equatable {}
extension MobileWorkflowCore.CredentialError : Swift.Hashable {}
extension MobileWorkflowCore.SyncResult : Swift.Equatable {}
extension MobileWorkflowCore.SyncResult : Swift.Hashable {}
extension MobileWorkflowCore.ButtonStyle : Swift.Equatable {}
extension MobileWorkflowCore.ButtonStyle : Swift.Hashable {}
extension MobileWorkflowCore.ButtonStyle : Swift.RawRepresentable {}
extension MobileWorkflowCore.ReachabilityStatus : Swift.Equatable {}
extension MobileWorkflowCore.ReachabilityStatus : Swift.Hashable {}
extension MobileWorkflowCore.ReachabilityStatus : Swift.RawRepresentable {}
