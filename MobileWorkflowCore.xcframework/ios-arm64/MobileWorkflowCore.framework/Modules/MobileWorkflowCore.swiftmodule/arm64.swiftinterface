// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3 (swiftlang-1200.0.29.2 clang-1200.0.30.1)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name MobileWorkflowCore
import AVFoundation
import AVKit
import AppAuth
import AuthenticationServices
import Combine
import CoreLocation
import CryptoKit
import Foundation
import MediaPlayer
@_exported import MobileWorkflowCore
import ResearchKit.Private
import ResearchKit
import Security
import Swift
import UIKit
import VisionKit
public typealias Response<T> = (Swift.Result<T, Swift.Error>) -> Swift.Void
@_hasMissingDesignatedInitializers final public class NetworkManager {
  @objc deinit
}
public struct CacheStorage {
}
public struct CryptoManager {
}
public struct URLSchemeManager {
  public init(version: Swift.String = "v1", debugHost: Swift.String = "localhost", defaultPort: Swift.Int = 5000)
  public func parse(url: Foundation.URL) -> MobileWorkflowCore.AppConfigurationContext?
}
public enum CredentialType : Swift.String, Swift.CaseIterable {
  case token
  case refreshToken
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [MobileWorkflowCore.CredentialType]
  public static var allCases: [MobileWorkflowCore.CredentialType] {
    get
  }
}
public struct Credential : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol SecurityStoreProtocol {
  func storePassword(key: Swift.String, value: Foundation.Data) -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
  func password(for key: Swift.String) -> Swift.Result<Foundation.Data?, MobileWorkflowCore.CredentialError>
  func removePassword(key: Swift.String) -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
}
final public class SecurityStore : MobileWorkflowCore.SecurityStoreProtocol {
  public init()
  final public func storePassword(key: Swift.String, value: Foundation.Data) -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
  final public func password(for key: Swift.String) -> Swift.Result<Foundation.Data?, MobileWorkflowCore.CredentialError>
  final public func removePassword(key: Swift.String) -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
  @objc deinit
}
public protocol SessionProvider {
}
public class Session {
  public init(providers: [Swift.String : MobileWorkflowCore.SessionProvider] = [:])
  @objc deinit
}
public class AppConfigurationManager {
  public init(stepsSession: MobileWorkflowCore.Session = Session(), urlSession: Foundation.URLSession = .shared, factories: [MobileWorkflowCore.StepFactory] = [], imageLoader: MobileWorkflowCore.ImageLoader? = nil, cache: MobileWorkflowCore.CacheStorage? = nil, cryptor: MobileWorkflowCore.CryptoManager? = nil, outputDirectory: Swift.String = NSTemporaryDirectory(), authRedirectHandler: MobileWorkflowCore.AuthRedirectHandler? = nil, bundle: Foundation.Bundle = .main)
  @objc deinit
}
public protocol CredentialsStoreProtocol {
  func updateCredential(_ credential: MobileWorkflowCore.Credential, completion: @escaping MobileWorkflowCore.Response<Swift.Void>)
  func retrieveCredential(_ credentialType: MobileWorkflowCore.CredentialType) -> Swift.Result<MobileWorkflowCore.Credential?, MobileWorkflowCore.CredentialError>
  func removeCredential(_ credentialType: MobileWorkflowCore.CredentialType) -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
  func wipeCredentials() -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
}
final public class CredentialsStore : MobileWorkflowCore.CredentialsStoreProtocol {
  public init(securityStore: MobileWorkflowCore.SecurityStoreProtocol = SecurityStore())
  final public func updateCredential(_ credential: MobileWorkflowCore.Credential, completion: @escaping MobileWorkflowCore.Response<Swift.Void>)
  final public func removeCredential(_ credentialType: MobileWorkflowCore.CredentialType) -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
  final public func retrieveCredential(_ credentialType: MobileWorkflowCore.CredentialType) -> Swift.Result<MobileWorkflowCore.Credential?, MobileWorkflowCore.CredentialError>
  final public func wipeCredentials() -> Swift.Result<Swift.Void, MobileWorkflowCore.CredentialError>
  @objc deinit
}
public protocol ImageLoader {
  func syncLoad(image: Swift.String) -> UIKit.UIImage?
  func asyncLoad(image: Swift.String, completion: ((UIKit.UIImage?) -> Swift.Void)?) -> Combine.AnyCancellable?
}
@objc @_hasMissingDesignatedInitializers public class MobileWorkflowRootViewController : UIKit.UIViewController, ResearchKit.ORKTaskViewControllerDelegate {
  public init(manager: MobileWorkflowCore.AppConfigurationManager, preferredConfigurations: [MobileWorkflowCore.AppConfigurationContext] = [], credentialsStore: MobileWorkflowCore.CredentialsStoreProtocol = CredentialsStore())
  @objc override dynamic public func viewDidLoad()
  public func loadAppConfiguration(_ context: MobileWorkflowCore.AppConfigurationContext)
  @objc public func taskViewController(_ taskViewController: ResearchKit.ORKTaskViewController, didFinishWith reason: ResearchKit.ORKTaskViewControllerFinishReason, error: Swift.Error?)
  @objc public func taskViewController(_ taskViewController: ResearchKit.ORKTaskViewController, stepViewControllerWillAppear stepViewController: ResearchKit.ORKStepViewController)
  @objc public func taskViewController(_ taskViewController: ResearchKit.ORKTaskViewController, stepViewControllerWillDisappear stepViewController: ResearchKit.ORKStepViewController, navigationDirection direction: ResearchKit.ORKStepViewControllerNavigationDirection)
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
public protocol StepFactory {
  func doesSupport(className: Swift.String) -> Swift.Bool
  func load(_ data: MobileWorkflowCore.StepData, imageLoader: MobileWorkflowCore.ImageLoader, networkManager: MobileWorkflowCore.NetworkManager, localizationManager: MobileWorkflowCore.Localization) throws -> ResearchKit.ORKStep
}
public struct StepData : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum AppConfigurationContext {
  case urlContext(url: Swift.String, serverId: Swift.Int?)
  case cached
  case file(path: Swift.String, serverId: Swift.Int?)
}
extension AppConfigurationContext {
  public init?(from urlContexts: Swift.Set<UIKit.UIOpenURLContext>, with urlSchemeManager: MobileWorkflowCore.URLSchemeManager = URLSchemeManager())
  public init(with filePath: Swift.String, serverId: Swift.Int? = nil)
  public var needsCleanUserSession: Swift.Bool {
    get
  }
  public var shouldShowLoadingActivity: Swift.Bool {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Localization {
  @objc deinit
}
public enum CredentialError : Swift.Error {
  case invalidInputData
  case storingError
  case unexpected
  public static func == (a: MobileWorkflowCore.CredentialError, b: MobileWorkflowCore.CredentialError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct AuthRedirectHandler {
  public init(_ handler: @escaping (MobileWorkflowCore.AuthFlowResumer) -> Swift.Void)
}
public protocol AuthFlowResumer : AnyObject {
  func resumeAuth(with url: Foundation.URL) -> Swift.Bool
}
public protocol AuthRedirector : AnyObject {
  var authFlowResumer: MobileWorkflowCore.AuthFlowResumer? { get set }
}
extension AuthRedirector {
  public func authRedirectHandler() -> MobileWorkflowCore.AuthRedirectHandler
  public func handleAuthRedirect(for url: Foundation.URL) -> Swift.Bool
}
extension MobileWorkflowCore.CredentialType : Swift.Equatable {}
extension MobileWorkflowCore.CredentialType : Swift.Hashable {}
extension MobileWorkflowCore.CredentialType : Swift.RawRepresentable {}
extension ResearchKit.ORKQuestionResult : MobileWorkflowCore.SessionProvider {}
extension ResearchKit.ORKFileResult : MobileWorkflowCore.SessionProvider {}
extension MobileWorkflowCore.CredentialError : Swift.Equatable {}
extension MobileWorkflowCore.CredentialError : Swift.Hashable {}
